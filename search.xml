<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[div3G.Teams]]></title>
    <url>%2F2019%2F04%2F18%2FTeams%2F</url>
    <content type="text"><![CDATA[Codeforces Round #552 (Div. 3) G. Two Teams 题意找到俩个数使他俩的LCM最小,输出这俩个数的下标。 思路 每次枚举每个数的因子,然后求lcm,将最小的LCM的俩个下标存起来。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e7+10;int a[maxn];int v[maxn];int main()&#123; int n; cin&gt;&gt;n; int maxx=0; int ans0=0x3f3f3f3f,ans1=0x3f3f3f3f; long long ma=1e16; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; maxx=max(maxx,a[i]); if(v[a[i]])&#123; long long temp=a[i]; if(ma&gt;temp)&#123; ma=temp; ans0=v[a[i]]; ans1=i; &#125; &#125; v[a[i]]=i; &#125; for(int i=1;i&lt;=maxx;i++)&#123; int ans00=-1,ans11=-1; for(int j=i;j&lt;=maxx;j+=i)&#123; if(v[j])&#123; if(ans00==-1) ans00=j; else ans11=j; &#125; if(ans11!=-1&amp;&amp;ans00!=-1) break; &#125; if(ans11!=-1)&#123; long long temp=1ll*ans11*ans00/i; if(ma&gt;temp)&#123; ma=temp; ans0=v[ans00]; ans1=v[ans11]; &#125; &#125; &#125; if(ans0&gt;ans1) swap(ans0,ans1); printf("%d %d\n",ans0,ans1);&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1091合唱队形]]></title>
    <url>%2F2019%2F04%2F16%2FP1091%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[P1091 合唱队形 题意n位同学站成一排,要求满足所选同学的身高严格单调递增在递减，问最少需要几位同学出列 思路 先正的求一遍LIS，在逆着求一边LIS，最后再求以i(1&lt;=i&lt;=n)为一个转折点求最大的和即为所要求的人（这里要减去1不仅要防止不选还要防止选这一位置俩次），最后在用总数减去这个最大的人数即为所求答案。用贪心加二分的LIS求最长连续子序列，复杂度为o(n). 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100+10;int dp[2][maxn];int a[maxn];int b[maxn];int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; b[1]=a[1]; dp[0][1]=1; int pos=1; for(int i=2;i&lt;=n;i++)&#123; if(a[i]&gt;b[pos]) &#123; pos++; dp[0][i]=pos; b[pos]=a[i]; &#125; else &#123; b[lower_bound(b+1,b+pos+1,a[i])-b]=a[i]; dp[0][i]=pos; &#125; &#125; b[1]=a[n]; dp[1][1]=1; pos=1; for(int i=n-1,j=2;i&gt;=1;i--,j++)&#123; if(a[i]&gt;b[pos]) &#123; pos++; dp[1][j]=pos; b[pos]=a[i]; &#125; else &#123; b[lower_bound(b+1,b+pos+1,a[i])-b]=a[i]; dp[1][j]=pos; &#125; &#125; int maxx=0; for(int i=1;i&lt;=n;i++)&#123; maxx=max(maxx,dp[0][i]+dp[1][n-i+1]-1); &#125; printf("%d\n",n-maxx);&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>LIS</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Median String]]></title>
    <url>%2F2019%2F04%2F15%2F%E6%A8%A1%E6%8B%9F%E6%8B%9F-%E4%B8%AD%E7%AD%89%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Codeforces Round #550 (Div. 3)E. Median String 题意：输入一个n表示一个字符串里面有几个字符，然后寻找这俩个字符串中间的字符。 思路：模拟26位进制数表示 代码：123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+10;int ans[maxn];int main()&#123; int n; cin&gt;&gt;n; string a,b; cin&gt;&gt;a&gt;&gt;b; for(int i=n-1;i&gt;=0;i--)&#123; ans[i]=a[i]-'a'+b[i]-'a'; if(ans[i]&amp;1)&#123; ans[i+1]+=13; ans[i]=ans[i]-1&gt;&gt;1; ans[i]+=ans[i+1]/26; ans[i+1]%=26; &#125; else&#123; ans[i]&gt;&gt;=1; &#125; &#125; for(int i=0;i&lt;n;i++) printf("%c",'a'+ans[i]); cout&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu4576 Robot]]></title>
    <url>%2F2019%2F04%2F14%2F%E6%A6%82%E7%8E%87dp%2F</url>
    <content type="text"><![CDATA[题意在一个环形区域里面分成n个部分，初始在第一个部分(顺时针1到n)，截下来有m次操作，每次可以顺势针或者逆时针走a步问最后走在l到r这个区域内的概率是多少？ 思路 一道标准的概率dp题，每次走路都由上一步推导而来，只需要将上一步所走的路存起来,最后再把l到r这个区间所有的概率加起来即可。 代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;double dp[2][210];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int n,m,l,r; while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;l&gt;&gt;r&amp;&amp;n+m+l+r)&#123; int t=0; for(int i=0;i&lt;=n;i++) dp[0][i]=0; dp[0][0]=1; while(m--)&#123; int x; cin&gt;&gt;x; for(int i=0;i&lt;n;i++) dp[t^1][i]=0; for(int i=0;i&lt;n;i++)&#123; if(dp[t][i])&#123; dp[t^1][(i+x)%n]+=0.5*dp[t][i]; dp[t^1][(i-x+n)%n]+=0.5*dp[t][i]; &#125; &#125; t^=1; &#125; double ans=0; for(int i=l-1;i&lt;=r-1;i++)&#123; ans+=dp[t][i]; &#125; printf("%.4lf\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>概率dp</category>
      </categories>
      <tags>
        <tag>概率dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论问题之质数]]></title>
    <url>%2F2019%2F04%2F12%2F%E6%95%B0%E8%AE%BA_%E8%B4%A8%E6%95%B0_%E6%95%B0%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[质数定义若一个正整数无法被1和它自身之外的任何自然数整除，则称该数为质数（素数），否则该数为合数。 质数的判定用试除法：1234567bool is_prime(int n)&#123; if(n&lt;2) return false; for(int i=2;i&lt;=sqrt(n);i++)&#123; if(n%i==0) return false; &#125; return true;&#125; 质数的筛选方法：埃式筛法和线性筛法：链接（之前写过，就不写了）。 质因数分解算术基本定理： 任何一个不大于1的正整数都能唯一分解为有限个质数的乘积，可写作 N=p1^c1^p2^c2^p3^c3^……pm^cm^ 其中ci为正整数，pi为质数，满足p1]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>质数</tag>
      </tags>
  </entry>
</search>
