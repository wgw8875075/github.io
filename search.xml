<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces Round]]></title>
    <url>%2F2019%2F04%2F15%2F%E6%A8%A1%E6%8B%9F%E6%8B%9F-%E4%B8%AD%E7%AD%89%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Codeforces Round #550 (Div. 3)E. Median String 题意：输入一个n表示一个字符串里面有几个字符，然后寻找这俩个字符串中间的字符。 思路：模拟26位进制数表示 代码：123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+10;int ans[maxn];int main()&#123; int n; cin&gt;&gt;n; string a,b; cin&gt;&gt;a&gt;&gt;b; for(int i=n-1;i&gt;=0;i--)&#123; ans[i]=a[i]-'a'+b[i]-'a'; if(ans[i]&amp;1)&#123; ans[i+1]+=13; ans[i]=ans[i]-1&gt;&gt;1; ans[i]+=ans[i+1]/26; ans[i+1]%=26; &#125; else&#123; ans[i]&gt;&gt;=1; &#125; &#125; for(int i=0;i&lt;n;i++) printf("%c",'a'+ans[i]); cout&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu4576 Robot]]></title>
    <url>%2F2019%2F04%2F14%2F%E6%A6%82%E7%8E%87dp%2F</url>
    <content type="text"><![CDATA[题意： 在一个环形区域里面分成n个部分，初始在第一个部分(顺时针1到n)，截下来有m次操作，每次可以顺势针或者逆时针走a步问最后走在l到r这个区域内的概率是多少？思路： 一道标准的概率dp题，每次走路都由上一步推导而来，只需要将上一步所走的路存起来,最后再把l到r这个区间所有的概率加起来即可。代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;double dp[2][210];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int n,m,l,r; while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;l&gt;&gt;r&amp;&amp;n+m+l+r)&#123; int t=0; for(int i=0;i&lt;=n;i++) dp[0][i]=0; dp[0][0]=1; while(m--)&#123; int x; cin&gt;&gt;x; for(int i=0;i&lt;n;i++) dp[t^1][i]=0; for(int i=0;i&lt;n;i++)&#123; if(dp[t][i])&#123; dp[t^1][(i+x)%n]+=0.5*dp[t][i]; dp[t^1][(i-x+n)%n]+=0.5*dp[t][i]; &#125; &#125; t^=1; &#125; double ans=0; for(int i=l-1;i&lt;=r-1;i++)&#123; ans+=dp[t][i]; &#125; printf(&quot;%.4lf\n&quot;,ans); &#125;&#125;]]></content>
      <categories>
        <category>概率dp</category>
      </categories>
      <tags>
        <tag>概率dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论问题之质数]]></title>
    <url>%2F2019%2F04%2F12%2F%E6%95%B0%E8%AE%BA_%E8%B4%A8%E6%95%B0_%E6%95%B0%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[质数定义若一个正整数无法被1和它自身之外的任何自然数整除，则称该数为质数（素数），否则该数为合数。 质数的判定用试除法：1234567bool is_prime(int n)&#123; if(n&lt;2) return false; for(int i=2;i&lt;=sqrt(n);i++)&#123; if(n%i==0) return false; &#125; return true;&#125; 质数的筛选方法：埃式筛法和线性筛法：链接（之前写过，就不写了）。 质因数分解算术基本定理： 任何一个不大于1的正整数都能唯一分解为有限个质数的乘积，可写作 N=p1^c1^p2^c2^p3^c3^……pm^cm^ 其中ci为正整数，pi为质数，满足p1&lt;p2&lt;p3&lt;……&lt;pm.试除法 扫描2-sqrt(n)的每一个数d，若d能整除n，则从n中除掉所有的因子d，同时可以累计d的个数。最后特别的需要判定，若最后n&gt;1,则说明n为质数。123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e6+10;int p[N],c[N],m;//p数组表示n的因子，c数组表示对应的因子的个数void devide(int n)&#123; memset(c,0,sizeof(c)); m=0;//m记录的多少个因子 for(int i=2;i*i&lt;=n;i++)&#123; if(n%i==0)&#123; p[++m]=i; while(n%i==0) n/=i,c[m]++; &#125; &#125; if(n&gt;1) c[++m]=n,c[m]++; for(int i=1;i&lt;=m;i++)&#123; cout&lt;&lt;p[i]&lt;&lt;'^'&lt;&lt;c[i]&lt;&lt;endl; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; devide(n); system("pause");&#125; poj1845Sumdiv题意：求A^B^的所有约数之和mod9901.思路： 把A分解质因数A=p1^c1^p2^c2^p3^c3^……pm^cm^ A^B^=p1^Bc1^p2^Bc2^p3^Bc3^……pm^Bcm^ 根据乘法分配律，A^B^的所有约数之和就是： (1+p1^1^+p1^2^+p1^3^+……+p1^Bc1^)(1+p2^1^+p2^2^+p2^3^+……+p2^Bc2^) …… (1+pm^1^+pm^2^+pm^3^+……+pm^Bcm^) 在使用分治法求sum(p,c)=1+p^1^+p^2^+p^3^+……+p^c^ 当c为奇数时有偶数项，当c为偶数时有奇数项 c为奇数：sum(p,c)=1+p^1^+p^(c-1)/2^+……+p^(c+1)/2^+……+p^c^ =(1+p^1^+……+p^(c-1)/2^)+p^(c+1)/2^ (1+p^1^+……+p^(c-1)/2^) =(1+p^(c+1)/2^) (1+p^1^+……+p^(c-1)/2^) =(1+p^(c+1)/2^) sum(p,(c-1)/2) c为偶数：sum(p,c)=1+p^1^+p^(c-2)/2^+……+p^c/2^+……+p^c-1^+p^c^ ==(1+p^c/2^) sum(p,c/2-1)+p^c^ 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int mod=9901;vector&lt;pair&lt;int ,int&gt; &gt; v;int ksm(int p,int c)&#123; int ans=1; p%=mod; while(c)&#123; if(c&amp;1) ans=1ll*ans*p%mod; p=1ll*p*p%mod; c&gt;&gt;=1; &#125; return ans;&#125;int get_sum(int p,int c)&#123; if(!p) return 0; if(!c) return 1; if(c&amp;1) return 1ll*(ksm(p,(c+1)/2)+1)*get_sum(p,(c-1)/2)%mod; else return (1ll*(ksm(p,c/2)+1)*get_sum(p,c/2-1)+ksm(p,c))%mod;&#125;int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; for(int i=2;i*i&lt;=a;i++)&#123; if(a%i==0)&#123; int sum=0; while(a%i==0)&#123; sum++; a/=i; &#125; v.push_back(make_pair(i,sum)); &#125; &#125; if(a&gt;1) v.push_back(make_pair(a,1)); int ans=1; for(int i=0;i&lt;v.size();i++)&#123; int p=v[i].first,c=v[i].second; ans=1ll*ans*get_sum(p,b*c)%mod; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; poj2689Prime Distance题意： 给定俩个整数L,R（1&lt;=L&lt;=R&lt;=2^31^,R-L&lt;=10^6^）,求闭区间[L,R]内 相邻来个数的差最大是多少，输出这俩个质数。 思路：因为L,R的范围很大不能使用暴力做法，但是R-L的值小，我们可以先筛选出2-sqrt( R)之间的左右质数，然后在用这些质数去筛选L-R内的所有质数，最终没有被标记的就是L-R内的质数。先处理2-sqrt(2^31^)内的质数，sqrt(2^31^)约等于46340.(可以打表也可以使用线性筛)。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;const int M=46430,N=1e6+10,INF=0x7fffffff;vector&lt;int&gt; p,ans;bool v[N];int main()&#123; memset(v,1,sizeof(v)); for(int i=2;i&lt;=M;i++)&#123; if(v[i])&#123; p.push_back(i); for(int j=2;j&lt;=M/i;j++) v[i*j]=0; &#125; &#125; int l,r; while(cin&gt;&gt;l&gt;&gt;r)&#123; memset(v,1,sizeof(v)); ans.clear(); if(l==1) v[0]=0; for(int i=0;i&lt;p.size();i++)&#123; for(int j=(l-1)/p[i]+1;j&lt;=r/p[i];j++)&#123; if(j&gt;1) v[p[i]*j-l]=0; &#125; &#125; for(unsigned int i=l;i&lt;=r;i++) if(v[i-l]) ans.push_back(i); int minn=INF,maxx=0,x1,x2,y1,y2; for(int i=0;i&lt;ans.size()-1;i++)&#123; int d=ans[i+1]-ans[i]; if(d&lt;minn)&#123; minn=d; x1=ans[i]; y1=ans[i+1]; &#125; if(d&gt;maxx)&#123; maxx=d; x2=ans[i]; y2=ans[i+1]; &#125; &#125; if (!maxx) puts("There are no adjacent primes."); else printf("%d,%d are closest, %d,%d are most distant.\n", x1, y1, x2, y2); &#125;&#125; CH3101阶乘分解题意： 给定整数N(1&lt;=N&lt;=10^6^),试把阶乘N！分解质因数，按照算术基本定理的形式输出分解结果中的pi和c1.思路： N！的质因数p的个数就是1-N中每个数包含质因数p的个数和，包含质因子p的个数为N/p，接下来计算p^2^的个数为N/p^2^，直到N/(longN/longp),加在一块就是p的个数和。代码：12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int isprime[1000000+10];int prime[1000000+10];int c;void Prime(int n) &#123; memset(isprime,1,sizeof(isprime)); isprime[0]=isprime[1]=0; for(int i=2;i&lt;=n;i++) &#123; if(isprime[i]) prime[c++] = i; for(int j = 0; (j&lt;c &amp;&amp; i*prime[j]&lt;=n);j++) &#123; isprime[i*prime[j]]=0; if(!(i%prime[j])) break; &#125; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; Prime(n); for(int i=0;i&lt;c;i++) &#123; int p=prime[i]; int sum=0; for(int j=n;j&gt;=1;j/=p) sum+=j/p; printf("%d %d\n",p,sum); &#125;&#125; 参考书籍：算法竞赛进阶指南]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>质数</tag>
      </tags>
  </entry>
</search>
