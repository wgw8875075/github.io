<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[判断一颗树是否有环]]></title>
    <url>%2F2019%2F06%2F19%2F%E5%88%A4%E6%96%AD%E4%B8%80%E9%A2%97%E6%A0%91%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[判断一个树是否有环123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;int flag=1;int v[100];int head[100],ver[100&lt;&lt;1],nex[100&lt;&lt;1];int tot;void add(int x,int y)&#123; ver[++tot]=y,nex[tot]=head[x],head[x]=tot;&#125;bool dfs(int now,int fa)&#123; // printf("now=%d\n",now); v[now]=1; for(int i=head[now];i;i=nex[i])&#123; int y=ver[i]; // printf("y=%d\n",y); // printf("%d %d\n",now,y); if(y==fa) continue; else &#123; // printf("%d %d\n",now,y); if(v[y]) return 1; if(dfs(y,now)) return 1; &#125; &#125; return 0;&#125;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; add(x,y); add(y,x); &#125; if(dfs(1,0)) printf("you\n"); else printf("wu\n"); for(int i=1;i&lt;=n;i++) printf("%d",v[i]); //system("pause");&#125;]]></content>
      <categories>
        <category>倍增</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倍增题]]></title>
    <url>%2F2019%2F06%2F16%2F%E5%80%8D%E5%A2%9E%2F</url>
    <content type="text"><![CDATA[牛客 区间的连续段题意​ 给你一个长为n的序列a和一个常数k ，有m次询问，每次查询一个区间[l,r]内所有数最少分成多少个连续段，使得每段的和都 &lt;= k ，如果这一次查询无解，输出”Chtholly”。 思路​ 求前缀和，然后先预处理出走一步所能到达得最远的位置，然后用dp[i][j]表示从i点出发分成1&lt;&lt;j段的最远所到达的位置 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;long long a[maxn];int dp[maxn][37];int main()&#123; int n,k,m; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;a[i]); a[i]+=a[i-1]; &#125; a[n+1]=a[n]+k; for(int i=1;i&lt;=n;i++)&#123; int p=lower_bound(a+1,a+n+1,a[i-1]+k+1)-a; dp[i][0]=p; &#125; for(int i=0;i&lt;=31;i++) dp[n+1][i]=n+1; for(int j=1;j&lt;=31;j++)&#123; for(int i=1;i&lt;=n;i++)&#123; dp[i][j]=dp[dp[i][j-1]][j-1]; &#125; &#125; while(m--)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); int ans=0; for(int i=31;i&gt;=0;i--)&#123; if(dp[l][i]&lt;=r)&#123; l=dp[l][i]; ans+=(1&lt;&lt;i); &#125; &#125; if(dp[l][0]&lt;=r) printf("Chtholly\n"); else printf("%d\n",ans+1); &#125; //system("pause");&#125; Educational Codeforces Round 66 (Rated for Div. 2)题意​ 求覆盖目标区域至少需要多少个区间 思路​ dp[i][j]表示从i点出发需要最少需要1&lt;&lt;j的区间覆盖。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e5+10;int a[maxn];int dp[maxn][33];int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); dp[l][0]=max(dp[l][0],r); &#125; for(int i=1;i&lt;maxn;i++) dp[i][0]=max(&#123;dp[i-1][0],dp[i][0]&#125;); for(int j=1;j&lt;=31;j++)&#123; for(int i=0;i&lt;maxn;i++)&#123; dp[i][j]=dp[dp[i][j-1]][j-1]; &#125; &#125; for(int i=0;i&lt;5;i++)&#123; for(int j=0;j&lt;5;j++)&#123; printf("%d ",dp[i][j]); &#125; puts(""); &#125; while(m--)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); int ans=0; if(dp[l][31]&lt;r)&#123; printf("-1\n"); continue; &#125; for(int i=31;i&gt;=0;i--)&#123; if(dp[l][i]&lt;r)&#123; ans+=(1&lt;&lt;i); l=dp[l][i]; &#125; &#125; printf("%d\n",ans+1); &#125; //system("pause");&#125;]]></content>
      <categories>
        <category>倍增</category>
      </categories>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler Problem 51]]></title>
    <url>%2F2019%2F06%2F09%2Feuler%2F</url>
    <content type="text"><![CDATA[Project Euler Problem 51 Prime digit replacements题意​ 将两位数*3的第一个数字代换为任意数字，在九个可能值中有六个是素数：13、23、43、53、73和83。 ​ 将五位数56**3的第三和第四位数字代换为相同的任意数字，就得到了十个可能值中有七个是素数的最小例子，这个素数族是：56003、56113、56333、56443、56663、56773和56993。56003作为这一族中最小的成员，也是最小的满足这个性质的素数。 ​ 通过将部分数字（不一定相邻）代换为相同的任意数字，有时能够得到八个素数，求满足这一性质的最小素数。 答案是*2*3*3 思路​ (1)先打个素数表 ​ (2)对每个素数进行位数计算(计算有几位)，然后枚举换哪一位（我用二进制下进行枚举，个位不能进行枚举，枚举个位的话有一般都是偶数，所有从十位开始枚举） ​ (3)用set存数最后计算set的大小是否等于8，输出结果。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int v[maxn];void prime(int n)&#123; memset(v,0,sizeof v); for(int i=2;i&lt;=n;i++)&#123; if(v[i]) continue; for(int j=i;j&lt;=n/i;j++) v[i*j]=1; &#125;&#125;bool check(int n)&#123; int a[10]; int x=n; int id=0; while(x&gt;0)&#123; a[++id]=x%10; x/=10; &#125; for(int i=1;i&lt;(1&lt;&lt;(id-1));i++)&#123; set&lt;int&gt; s; for(int j=0;j&lt;=9;j++)&#123; int b[10]; for(int k=1;k&lt;=id;k++) b[k]=a[k]; for(int k=0;k&lt;=4;k++) if(i&amp;(1&lt;&lt;k)) b[k+2]=j; int ans=0; for(int k=id;k&gt;=1;k--) ans=ans*10+b[k]; if(!v[ans]) s.insert(ans); &#125; if(*s.begin()==n&amp;&amp;s.size()==8) return 1; &#125; return 0;&#125;int main()&#123; prime(maxn); for(int i=101;i&lt;1000000;i+=2)&#123; if(!v[i]&amp;&amp;check(i))&#123; printf("%d\n",i); break; &#125; &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>Project Euler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TSP小测]]></title>
    <url>%2F2019%2F05%2F24%2FTSP%E5%B0%8F%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[POJ5067题意​ 有一个n*m的矩阵上存在一些石头，接下来要从起点出发把这些石头拿上并回到起点，问最小需要多少步。 思路​ 用sum表示除了(1,1)这个点外其他有石头的点的个数，用x数组和y数组表示这些点的坐标的位置，在这里我用二进制下的每个位置表示点的位置，将最后的位置来表示起点，0 - n-1分别表示其他点的位置，然后开始暴力枚举二进制下的每个数字，注意初始化dp[0] [n]=0. 代码 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int x[20],y[20];int ma[60][60];int dp[1&lt;&lt;12][15];int dis(int i,int j)&#123; return abs(x[i]-x[j])+abs(y[i]-y[j]);&#125;int main()&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; int sum=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; scanf("%d",&amp;ma[i][j]); if(i==1&amp;&amp;j==1) continue; if(ma[i][j])&#123; x[sum]=i; y[sum]=j; sum++; &#125; &#125; x[sum]=1,y[sum]=1; n=sum; memset(dp,0x3f,sizeof(dp)); dp[0][n]=0; for(int st=0;st&lt;(1&lt;&lt;n);st++)&#123; for(int i=0;i&lt;=n;i++)&#123; dp[st][n]=min(dp[st][n],dp[st][i]+dis(i,n)); for(int j=0;j&lt;n;j++)&#123; dp[st|1&lt;&lt;j][j]=min(dp[st|1&lt;&lt;j][j],dp[st][i]+dis(i,j)); &#125; &#125; &#125; printf("%d\n",dp[(1&lt;&lt;n)-1][n]); &#125;&#125; HDU3311题意​ 给n个地点，然后输入一个(n+1)*(n+1)的矩阵，第i行第j列表示第i个地点到第j个地点的时间，要从第0个地点用最短的时间走遍1-n个地点，并回到原点。 思路​ 先用Floyd最短路径算法求出任意俩点之间的最短时间，接下来就是一个TSP板子，记住最后再让他回到原点就行了。 代码123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std ;int d[20][20];int dp[1&lt;&lt;12][20];int main()&#123; int n; while(~scanf("%d",&amp;n))&#123; if(n==0) break; for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=n;j++)&#123; scanf("%d",&amp;d[i][j]); &#125; &#125; for(int k=0;k&lt;=n;k++) for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]); memset(dp,0x3f,sizeof(dp)); dp[1][0]=0; n++; for(int i=1;i&lt;1&lt;&lt;n;i++) for(int j=0;j&lt;n;j++) if(i&gt;&gt;j&amp;1) for(int k=0;k&lt;n;k++) if((i^1&lt;&lt;j)&gt;&gt;k&amp;1) dp[i][j]=min(dp[i][j],dp[i^1&lt;&lt;j][k]+d[k][j]); int ans=0x3f3f3f3f; for(int i=1;i&lt;n;i++) ans=min(ans,dp[(1&lt;&lt;n)-1][i]+d[i][0]); printf("%d\n",ans); &#125;&#125; HDU4856题意​ 有一个n*n的地图，.表示可行走的路，#表示障碍，接下来有m行，x1,y2,x2,y2分别表示隧道的入口和出口，最后求走完这些隧道并且只能走一次需要多长时间。 思路​ 首先bfs所有隧道从入口到另一个隧道出口的时间，如果不能到达将它置为-1，然后就是初始化从每个起点出发（也就是for(int i=0;i&lt;m;i++) dp[1&lt;&lt;i] [i]=0;）剩下的就越是单纯的TSP模板了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int INF = 0x3f3f3f3f;struct point&#123; int x1,y1,x2,y2;&#125;p[17];int n,m;char ma[17][17];int mp[17][17],visit[17][17],dp[1&lt;&lt;15][17];int step[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;bool check(int x,int y)&#123; return x&lt;=n&amp;&amp;x&gt;=1&amp;&amp;y&lt;=n&amp;&amp;y&gt;=1&amp;&amp;ma[x][y]!='#';&#125; int bfs(point x,point y)&#123; queue&lt;pair&lt;int,int&gt; &gt; q; memset(visit,-1,sizeof(visit)); q.push(make_pair(x.x2,x.y2)); visit[x.x2][x.y2]=0; while(q.size())&#123; pair&lt;int,int&gt; now=q.front(); q.pop(); if(now.first==y.x1&amp;&amp;now.second==y.y1) return visit[y.x1][y.y1]; for(int i=0;i&lt;=3;i++)&#123; int tx=now.first+step[i][0],ty=now.second+step[i][1]; if(check(tx,ty)&amp;&amp;visit[tx][ty]==-1) &#123; visit[tx][ty]=visit[now.first][now.second]+1; q.push(make_pair(tx,ty)); &#125; &#125; &#125; return -1;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; for(int i=1;i&lt;=n;i++) scanf("%s",ma[i]+1); for(int i=0;i&lt;m;i++)&#123; scanf("%d%d%d%d",&amp;p[i].x1,&amp;p[i].y1,&amp;p[i].x2,&amp;p[i].y2); &#125; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(i==j) mp[i][j]=0; else mp[i][j]=bfs(p[i],p[j]); &#125; &#125; for(int i=1;i&lt;1&lt;&lt;m;i++)&#123; for(int j=0;j&lt;m;j++)&#123; dp[i][j]=0x3f3f3f3f; &#125; &#125; for(int i=0;i&lt;m;i++) dp[1&lt;&lt;i][i]=0; for(int i=0;i&lt;1&lt;&lt;m;i++)&#123; for(int j=0;j&lt;m;j++) if(i&gt;&gt;j&amp;1) for(int k=0;k&lt;m;k++) if(((i^1&lt;&lt;j)&gt;&gt;k&amp;1)&amp;&amp;mp[k][j]!=-1) dp[i][j]=min(dp[i][j],dp[i^1&lt;&lt;j][k]+mp[k][j]); &#125; int ans=0x3f3f3f3f; for(int i=0;i&lt;m;i++) ans=min(ans,dp[(1&lt;&lt;m)-1][i]); if(ans==0x3f3f3f3f) printf("-1\n"); else printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>状态压缩DP</category>
      </categories>
      <tags>
        <tag>状态压缩DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论小测]]></title>
    <url>%2F2019%2F05%2F09%2F%E6%95%B0%E8%AE%BA%E5%B0%8F%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[hdu5207Greatest Greatest Common Divisor题意​ 给定n个数求任意俩个数得最大公因数 思路​ 因为之前写过求俩个数得最小公倍数，所以这道问题迎刃而解，就是枚举他们得因数，用数组记录每个因数出现的次数，最后从大到小找出现俩次得那个数，输出即可。 代码1123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;int a[maxn];int main()&#123; int t; cin&gt;&gt;t; int id=0; while(t--)&#123; memset(a,0,sizeof a); int n; scanf("%d",&amp;n); int maxx=-1; for(int i=1;i&lt;=n;i++)&#123; int x; scanf("%d",&amp;x); maxx=max(x,maxx); for(int i=1;i*i&lt;=x;i++)&#123; if(!(x%i))&#123; a[i]++; if(x/i!=i)&#123; a[x/i]++; &#125; &#125; &#125; &#125; int ans=0; for(int i=maxx;i&gt;=1;i--)&#123; if(a[i]&gt;=2) &#123; ans=i; break; &#125; &#125; printf("Case #%d: %d\n",++id,ans); &#125;&#125; 但后来听大佬的正解，发现是先预处理出所有数的因数直接在循环中累计个数就🆗了。 代码212345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;vector&lt;int&gt; c[maxn];int v[maxn];void init()&#123; for(int i=1;i&lt;maxn;i++)&#123; for(int j=i;j&lt;maxn;j+=i)&#123; c[j].push_back(i); &#125; &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; init(); int id=0; while(t--)&#123; memset(v,0,sizeof v); int n; cin&gt;&gt;n; int maxx=-1; for(int i=1;i&lt;=n;i++)&#123; int x; cin&gt;&gt;x; maxx=max(maxx,x); for(int j=0;j&lt;c[x].size();j++)&#123; v[c[x][j]]++; &#125; &#125; int x=0; for(int i=maxx;i&gt;=1;i--)&#123; if(v[i]&gt;=2)&#123; x=i; break; &#125; &#125; printf("Case #%d: %d\n",++id,x); &#125; //system("pause"); return 0;&#125; HDU5698瞬间移动题意​ 无限大的矩形，从(1,1)每次可以瞬移到右下方格的任意一个格子，求最后到达(n,m)的方案数。 思路​ 枚举中间走的步数i，中间走的最大步数必然是min(m-2,n-2)步，然后开始枚举。 代码112345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int mod=1e9+7;const int maxn=1e6+10;int jc[maxn],jcinv[maxn];int C(int n,int m)&#123; return 1ll*jc[n]*jcinv[m]%mod*jcinv[n-m]%mod;&#125;int ksm(int a,int b)&#123; int c=1; for(;b;b&gt;&gt;=1)&#123; if(b&amp;1) c=1ll*c*a%mod; a=1ll*a*a%mod; &#125; return c;&#125;int main()&#123; jc[0]=1,jcinv[0]=1; jc[1]=1,jcinv[1]=1; for(int i=2;i&lt;=maxn;i++)&#123; jc[i]=1ll*jc[i-1]*i%mod; jcinv[i]=ksm(jc[i],mod-2); &#125; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; int ans=0; for(int i=0;i&lt;=min(n-2,m-2);i++)&#123; ans=(ans+1ll*C(n-2,i)*C(m-2,i)%mod)%mod; &#125; printf("%d\n",ans); &#125; return 0;&#125; 网上查阅的答案为C(n+m-4,n-2) 代码21234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int mod=1e9+7;const int maxn=1e6+10;int jc[maxn],jcinv[maxn];int C(int n,int m)&#123; return 1ll*jc[n]*jcinv[m]%mod*jcinv[n-m]%mod;&#125;int ksm(int a,int b)&#123; int c=1; for(;b;b&gt;&gt;=1)&#123; if(b&amp;1) c=1ll*c*a%mod; a=1ll*a*a%mod; &#125; return c;&#125;int main()&#123; jc[0]=1,jcinv[0]=1; jc[1]=1,jcinv[1]=1; for(int i=2;i&lt;=maxn;i++)&#123; jc[i]=1ll*jc[i-1]*i%mod; jcinv[i]=ksm(jc[i],mod-2); &#125; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; printf("%d\n",C(n+m-4,n-2)); &#125; return 0;&#125; cfdiv2 Modified GCD题意​ 给定俩个数a和b，然后给m个查询，每行俩个整数x和y，表示查询x到y之间最大a和b的因数。 思路​ 这也太简单了，直接预处理出gcd(a,b)的所有因数，排序，二分查找第一个比b大的数的下标位置，在把这个位置向后倒退一步，再判断是否为x-y这个区间内，是则输出，否则输出-1. 代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int c[maxn];int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; int x=__gcd(a,b); int id=0; for(int i=1;i*i&lt;=x;i++)&#123; if(x%i==0)&#123; c[++id]=i; if(x/i!=i) c[++id]=x/i; &#125; &#125; sort(c+1,c+id+1); // for(int i=1;i&lt;=id;i++) cout&lt;&lt;c[i]&lt;&lt;endl; int m; cin&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;a&gt;&gt;b; x=upper_bound(c+1,c+id+1,b)-c; x--; if(c[x]&lt;=b&amp;&amp;c[x]&gt;=a) cout&lt;&lt;c[x]&lt;&lt;endl; else cout&lt;&lt;-1&lt;&lt;endl; &#125; //system("pause"); return 0;&#125; BZOJ2818 Gcd题意​ 给定整数N，求1&lt;=x,y&lt;=N且Gcd(x,y)为素数的数对(x,y)有多少对. 思路​ 由题意得： ​ gcd(x,y)=p ​ gcd(x/p,y/p)=1 ​ 所以枚举每个素数(代码中m表示n以内的素数个数)，求n/p以内俩俩互质对数的个数，最后再乘p即为所求的gcd(x,y)=p ,因为俩个数顺序变换也算，所以最后乘2，另外(1,1)是个特殊的存在所以在计算的时候减去最后再加即可。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=1e7+10;int v[maxn],prime[maxn],phi[maxn];long long sum[maxn];int m;void euler(int n)&#123; memset(v,0,sizeof(v)); m=0; phi[1]=1; for(int i=2;i&lt;=n;i++)&#123; if(v[i]==0)&#123; v[i]=i; prime[++m]=i; phi[i]=i-1; &#125; for(int j=1;j&lt;=m;j++)&#123; if(prime[j]&gt;v[i]||prime[j]&gt;n/i) break; v[i*prime[j]]=prime[j]; phi[i*prime[j]]=phi[i]*(i%prime[j]?prime[j]-1:prime[j]); &#125; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; euler(n); for(int i=1;i&lt;=n;i++) sum[i]=phi[i]+sum[i-1]; long long ans=0; for(int i=1;i&lt;=m;i++) ans+=(sum[n/prime[i]]-1); printf("%lld\n",2*ans+m); //system("pause");&#125; POJ1061青蛙的约会题意​ 有俩个青蛙A和B，在一个长为l的环形上，初始时A在x处每次跳m米，B在y处每次跳n米，求最后需要跳几次才能相遇。 思路​ 很明显一个扩展欧几里得的模板题。 ​ 因为(x+mt)%l=(y+nt)%l, ​ 移项得(m-n)t%l=(y-x)%l ​ 得(m-n)t+lk=(y-x) ​ 对应扩展欧几里得中(ax+by=c) ， (m-n)为a，l为b ，c为(y-x). ​ 最后求得得数为x得解，因为可能为负数所以最后((x*c/gcd(a,b)%l)+l)%l。 代码1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(b==0) &#123;x=1,y=0;return a;&#125; ll d=exgcd(b,a%b,x,y); ll z=x;x=y;y=z-y*(a/b); return d;&#125;int main()&#123; ll n,m,x,y,l; while(~scanf("%lld%lld%lld%lld%lld",&amp;x,&amp;y,&amp;m,&amp;n,&amp;l))&#123; ll t,k; ll gcd=exgcd(m-n,l,t,k); ll c=(y-x)/gcd; if((y-x)%gcd) puts("Impossible"); else printf("%lld\n",((t*c)%l+l)%l); &#125;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU5242]]></title>
    <url>%2F2019%2F05%2F08%2FHDU524%2F</url>
    <content type="text"><![CDATA[HDU5242 题意​ 一棵树有n个结点，n-1条边，每个结点有个权值。每次可以获得从根节点走到叶子结点所有结点的权值和，但是每个结点的权值只能使用一次。求走k次所能获得的最大权值和。 思路​ 先进行第一次dfs，求出每条从根到叶子节点的链，然后将这些链排序，在进行第二遍dfs,求出抛去重复走的路径，在一次对所求的结果进行排序，取前m大加起来就行。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;typedef long long ll;int n,m;int head[maxn],ver[maxn],nex[maxn];int tot,p;int w[maxn];int visit[maxn],fa[maxn];ll ans[maxn];struct point&#123; ll x,y;&#125;a[maxn];bool cmp(point a,point b)&#123; return a.y&gt;b.y;&#125;void add(int u,int v)&#123; ver[++tot]=v,nex[tot]=head[u],head[u]=tot;&#125;void init()&#123; memset(head,0,sizeof head); memset(visit,0,sizeof visit); tot=0; p=0;&#125;void dfs(ll now,ll val)&#123; if(head[now])&#123; for(int i=head[now];i;i=nex[i])&#123; int y=ver[i]; dfs(y,val+w[now]); &#125; &#125; else &#123; a[++p].x=now,a[p].y=val+w[now]; &#125;&#125;ll dfs1(ll now)&#123; if(visit[now]) return 0; visit[now]=1; return dfs1(fa[now])+w[now];&#125;int main()&#123; int t; cin&gt;&gt;t; int id=0; while(t--)&#123; init(); scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); for(int i=1;i&lt;=n-1;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v); fa[v]=u; &#125; dfs(1,0); sort(a+1,a+p+1,cmp); for(int i=1;i&lt;=n;i++)&#123; ans[i]=dfs1(a[i].x); &#125; sort(ans+1,ans+p+1,greater&lt;ll&gt;()); ll res=0; for(int i=1;i&lt;=m;i++)&#123; res+=ans[i]; &#125; printf("Case #%d: %lld\n",++id,res); &#125; //system("pause");&#125;]]></content>
      <categories>
        <category>贪心</category>
        <category>dfs</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ4092]]></title>
    <url>%2F2019%2F05%2F08%2FZOJ4092%2F</url>
    <content type="text"><![CDATA[ZOJ4092 题意​ 求最后所给式子的和。 思路​ 因为2的30次方大于1e9，所以分母范围只可能是1-30，枚举分母预处理所有情况的前缀和，最后二分查找答案。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=5e5+10; const int mod=1e9;ll a[maxn],p[maxn];ll sum[maxn][31];int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=30;j++)&#123; sum[i][j]=sum[i-1][j]+a[i]/j; &#125; &#125; ll res=0; for(int i=1;i&lt;=m;i++)&#123; scanf("%d",&amp;p[i]); ll pp=p[i]; ll ans=0; //printf("i=%d\n",i); int l=1,r=1; for(int pos=1;pos&lt;=30;pp*=p[i],pos++)&#123; r=upper_bound(a+1,a+n+1,pp)-a; //printf("l=%d r=%d\n",l,r); ans=(ans+sum[r-1][pos]-sum[l-1][pos])%mod; l=r; if(pp&gt;a[n]) break; &#125; //printf("ans=%lld\n",ans); res=(res+i*ans%mod)%mod; &#125; printf("%lld\n",res); &#125; //system("pause");&#125;]]></content>
      <categories>
        <category>二分</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F24%2F%E4%BB%A3%E7%A0%81%EF%BC%9A%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 500000+10;const LL inf = 1e17;int n;int i,j;LL sum[maxn],stmx[maxn][23],stmn[maxn][23];int a[maxn],l[maxn],r[maxn];stack&lt;int&gt; sta;LL askmx(int l,int r)&#123; int k=log2(r-l+1); return max(stmx[l][k],stmx[r-(1&lt;&lt;k)+1][k]);&#125;LL askmn(int l,int r)&#123; int k=log2(r-l+1); return min(stmn[l][k],stmn[r-(1&lt;&lt;k)+1][k]);&#125;int main()&#123; scanf("%d",&amp;n); for (i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for (i=1;i&lt;=n;i++) sum[i]=sum[i-1]+(LL)a[i]; for (i=0;i&lt;=n;i++) stmx[i][0]=stmn[i][0]=sum[i]; for (j=1;(1&lt;&lt;j)&lt;=n+1;j++)&#123; for (i=0;i+(1&lt;&lt;j)-1&lt;=n;i++)&#123; stmx[i][j]=max(stmx[i][j-1],stmx[i+(1&lt;&lt;(j-1))][j-1]); stmn[i][j]=min(stmn[i][j-1],stmn[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125; for (i=1;i&lt;=n;i++)&#123; while (!sta.empty()&amp;&amp;a[i]&lt;=a[sta.top()]) sta.pop(); if (sta.empty()) l[i]=1; else l[i]=sta.top()+1; sta.push(i); &#125; while (!sta.empty()) sta.pop(); for (i=n;i&gt;=1;i--)&#123; while (!sta.empty()&amp;&amp;a[i]&lt;=a[sta.top()]) sta.pop(); if (sta.empty()) r[i]=n; else r[i]=sta.top()-1; sta.push(i); &#125; LL ans=-inf; for (i=1;i&lt;=n;i++)&#123; if (a[i]&lt;0)&#123; LL R=askmn(i,r[i]); LL L=askmx(l[i]-1,i-1); ans=max(ans,(R-L)*(LL)a[i]); &#125; else if (a[i]&gt;0)&#123; LL R=askmx(i,r[i]); LL L=askmn(l[i]-1,i-1); ans=max(ans,(R-L)*(LL)a[i]); &#125; else&#123; ans=max(ans,0ll); &#125; &#125; printf("%lld\n",ans); system("pause"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法作业一]]></title>
    <url>%2F2019%2F04%2F24%2F%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[归并排序1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;const int maxn=1e5+10;int tmp[maxn];int a[maxn];void merge( int start, int mid, int end)&#123; int i = start; int j = mid + 1; int k = 0; while(i &lt;= mid &amp;&amp; j &lt;= end)&#123; if (a[i] &lt;= a[j]) tmp[k++] = a[i++]; else tmp[k++] = a[j++]; &#125; while(i &lt;= mid) tmp[k++] = a[i++]; while(j &lt;= end) tmp[k++] = a[j++]; for (i = 0; i &lt; k; i++) a[start + i] = tmp[i];&#125;void mergeSort( int start, int end)&#123; if(start &gt;= end) return ; int mid = (end + start)/2; mergeSort( start, mid); mergeSort( mid+1, end); merge(start, mid, end);&#125;int main()&#123; int n; cin&gt;&gt;n; for (int i=1; i&lt;=n; i++) cin&gt;&gt;a[i]; mergeSort(1, n); for (int i=1; i&lt;=n; i++) cout &lt;&lt; a[i] &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; 棋盘覆盖123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e4+10;int m[maxn][maxn];int n=0;void chessboard(int x,int y,int tx,int ty,int s)&#123; if(s==1) return; s&gt;&gt;=1; int t=++n; if(tx&lt;=x+s-1&amp;&amp;ty&lt;=y+s-1) chessboard(x,y,tx,ty,s); else m[x+s-1][y+s-1]=t,chessboard(x,y,x+s-1,y+s-1,s); if(tx&lt;=x+s-1&amp;&amp;ty&gt;=y+s) chessboard(x,y+s,tx,ty,s); else m[x+s-1][y+s]=t,chessboard(x,y+s,x+s-1,y+s,s); if(tx&gt;=x+s&amp;&amp;ty&lt;=y+s-1) chessboard(x+s,y,tx,ty,s); else m[x+s][y+s-1]=t,chessboard(x+s,y,x+s,y+s-1,s); if(tx&gt;=x+s&amp;&amp;ty&gt;=y+s) chessboard(x+s,y+s,tx,ty,s); else m[x+s][y+s]=t,chessboard(x+s,y+s,x+s,y+s,s);&#125;int main()&#123; while(true)&#123; int size; cin&gt;&gt;size; int x,y; cin&gt;&gt;x&gt;&gt;y; chessboard(1,1,x,y,size); for(int i=1;i&lt;=size;i++)&#123; for(int j=1;j&lt;=size;j++)&#123; printf("%3d ",m[i][j]); &#125; printf("\n"); &#125; &#125;&#125; 循环日程表12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int n,half=1,k=1;int pic[100][100];int main()&#123; cin&gt;&gt;n; pic[0][0]=1; int m=1&lt;&lt;n; while(k&lt;=n)&#123; for(int i=0;i&lt;half;i++)&#123; for(int j=0;j&lt;half;j++)&#123; pic[i][j+half]=pic[i][j]+half; &#125; &#125; for(int i=0;i&lt;half;i++)&#123; for(int j=0;j&lt;half;j++)&#123; pic[i+half][j]=pic[i][j+half]; pic[i+half][j+half]=pic[i][j]; &#125; &#125; half*=2; k++; &#125; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;m;j++)&#123; printf("%3d",pic[i][j]); &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 快速排序1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;int a[maxn];void quicksort(int left,int right)&#123; if(left&gt;right) return ; int temp=a[left]; int i=left; int j=right; while(i!=j)&#123; while(a[j]&gt;=temp&amp;&amp;i&lt;j) j--; while(a[i]&lt;=temp&amp;&amp;i&lt;j) i++; if(i&lt;j)&#123; int t=a[i]; a[i]=a[j]; a[j]=t; &#125; &#125; a[left]=a[i]; a[i]=temp; quicksort(left,i-1); quicksort(i+1,right);&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; quicksort(1,n); for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;" "; puts(""); return 0;&#125;]]></content>
      <categories>
        <category>二分</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ST算法]]></title>
    <url>%2F2019%2F04%2F22%2FST%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[介绍RMQ (Range Minimum/Maximum Query)问题是指：对于长度为n的数列A，回答若干询问RMQ(A,i,j)(i,j&lt;=n)，返回数列A中下标在i,j里的最小(大）值，也就是说，RMQ问题是指求区间最值的问题。 ​ ST算法就是倍增的产物，ST算法能在O(nlogN)的预处理后，以O(1)的时间求出区间最值问题(当然也能求出其他问题)。思想上类似于动态规划，每次从上一次转移(状态转移方程看下面)。 思路​ 数列A是一个二维数组，A[i] [j]表示从第i个数字起长度为2的j次方的最大值。每次都成倍增长，公式 F[i,j]=max(F[i][j-1],F[i+2的(j-1)次方][j-1])长度为2的j次方的最大值是左右俩半长度为2的j-1次方的子区间中较大的一个。 代码预处理函数 123456789void ST()&#123; for(int i=1;i&lt;=n;i++) f[i][0]=a[i]; int t=log(n)/log(2)+1; for(int j=1;j&lt;t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125;&#125; 查询函数 1234int ST_query(int l,int r)&#123; int k=log(r-l+1)/log(2); return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125; 例题P3865 【模板】ST表 代码12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int n,m;int f[maxn][50];int a[maxn];void ST()&#123; for(int i=1;i&lt;=n;i++) f[i][0]=a[i]; int t=log(n)/log(2)+1; for(int j=1;j&lt;t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125;&#125;int ST_query(int l,int r)&#123; int k=log(r-l+1)/log(2); return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; ST(); for(int i=1;i&lt;=m;i++)&#123; int l,r; cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;ST_query(l,r)&lt;&lt;"\n"; &#125; system("pause");&#125;]]></content>
      <categories>
        <category>RMQ</category>
      </categories>
      <tags>
        <tag>RMQ</tag>
        <tag>ST算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长上升子序列LIS]]></title>
    <url>%2F2019%2F04%2F18%2F%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97(LIS)%2F</url>
    <content type="text"><![CDATA[介绍最长上升子序列问题，也就是Longest increasing subsequence，缩写为LIS。是指在一个序列中求长度最长的一个上升子序列的问题，是动态规划中一个相当经典问题。在这里我们可以看到，这个上升实质上就是一个对&lt;进行定义的过程，所以我们求解的其实是一类问题，也就是在给定序列中求解长度最长的符合某一性质的子序列的问题。 解法一状态设计：F[i]代表以A[i]结尾的LIS的长度状态转移：F[i]=max{F[j]+1}(1&lt;=j&lt; i,A[j]&lt; A[i])边界处理：F[i]=1(1&lt;=i&lt;=n)时间复杂度：O(n^2)PS(理解dp最简单的方法：画表，自行推理) 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int a[maxn],dp[maxn];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); dp[i]=1; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;i;j++)&#123; if(a[j]&lt;a[i]) dp[i]=max(dp[i],dp[j]+1); &#125; &#125; int maxx=0; for(int i=1;i&lt;=n;i++) maxx=max(maxx,dp[i]); printf("%d\n",maxx); return 0; &#125; 解法二贪心加二分 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;const int INF=0x7f7f7f7f;int a[maxn],dp[maxn];int binary_search(int l,int r,int x)&#123;//二分查找第一个大于等于x的元素 while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(dp[mid]&lt;=x) l=mid+1; else r=mid-1; &#125; return l;&#125;int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); dp[i]=INF;//初始化为无穷大 &#125; int pos=1; dp[1]=a[1]; for(int i=2;i&lt;=n;i++)&#123; if(a[i]&gt;dp[pos]) dp[++pos]=a[i];// else dp[lower_bound(dp+1,dp+pos+1,a[i])-dp]=a[i];//lower_bound(a,a+n,x)函数 返回从数组a到a+n中第一个&gt;=x的元素地址 else dp[binary_search(1,pos,a[i])]=a[i];//也可以自己写二分查找。 &#125; printf("%d\n",pos); return 0;&#125; 解法三用树状数组维护，降低复杂度。PS(我写完后发现这个方法将相等的也计算在其中)。不知道有没有人能去除掉相等，是我太菜了，QWQ.维护每个数的序列也就是第几个数，然后查询其前面的最长上升子序列，然后更新其后的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int n,dp[maxn];struct point&#123; int x,id; bool operator &lt; (const point &amp;a) const&#123; return x&lt;a.x||(a.x==x&amp;&amp;a.id&gt;id); &#125;&#125;;int lowbit(int x)&#123; return x&amp;(-x);&#125;int query(int x)&#123; int sum=0; while(x)&#123; sum=max(sum,dp[x]); x-=lowbit(x); &#125; return sum;&#125;void modify(int x,int y)&#123; while(x&lt;=n)&#123; dp[x]=max(dp[x],y); x+=lowbit(x); &#125;&#125;point a[maxn];int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i].x); a[i].id=i; &#125;// for(int i=1;i&lt;=n;i++) printf("%d %d\n",a[i].x,a[i].id);// printf("\n"); sort(a+1,a+n+1);// for(int i=1;i&lt;=n;i++) printf("%d %d\n",a[i].x,a[i].id); int ans=0; for(int i=1;i&lt;=n;i++)&#123; int maxx=query(a[i].id); modify(a[i].id,++maxx); ans=max(ans,maxx); &#125; printf("%d\n",ans); return 0;&#125; 解法四随后我查了相关的博客后，发现换个思维就可以排除相等的情况。即维护每一个刚输入的值，查询其前面的最长的上升子序列。 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int n,dp[maxn];int lowbit(int x)&#123; return x&amp;(-x);&#125;int query(int x)&#123; int sum=0; while(x)&#123; sum=max(sum,dp[x]); x-=lowbit(x); &#125; return sum;&#125;void modify(int x,int y)&#123; while(x&lt;=maxn)&#123; dp[x]=max(dp[x],y); x+=lowbit(x); &#125;&#125;int main()&#123; scanf("%d",&amp;n); int ans=0; for(int i=1;i&lt;=n;i++)&#123; int x; scanf("%d",&amp;x); x++;//因为树状数组从1开始，每次查询x-1以及前面的最大值 int maxx=query(x-1)+1; ans=max(ans,maxx); modify(x,maxx); &#125; printf("%d\n",ans);&#125; 不过解法三和四都有一定的局限性，只能所有数都是&gt;=1的正整数时才能用，不过这种思维可以用在好多地方。如果存在负数的情况，用方法二是最好的。]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>LIS</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj1845sumdiv]]></title>
    <url>%2F2019%2F04%2F18%2Fsumdiv%2F</url>
    <content type="text"><![CDATA[poj1845 sumdiv 题意求$A^B$的所有约束之和mod9901. 思路​ A可以写成 p_1^c1*p_2^c2*……*p_n^cn​ 然后 A^B可以写成p_1^c1^B*p_2^c2*B*……*p_n^cn*^B 然后A^B的约数可以写成 (1+p_1+p_1^2+……+p_1^c1^B)*(1+p_2+p_2^2+……+p_2^c2*B)*…… *(1+p_n+p_n^2+……+p_n^cn*^B)而等比数列的公式可以写成 (p_1^b*^c_1+1)/(p_1+1) (p_1-1)不是9901的倍数时可以用逆元求出但当(p_1-1)是9901的倍数时，无法求逆元 这时p_1模除9901时余1这时带入(1+p_i+p_i^2+……+p_i^ci*B)得到B*c_1+1这样问题就得以解决。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;const int mod=9901;int a,b;int p[20],c[20];int m=0;void divide(int x)&#123; for(int i=2;i*i&lt;=x;i++)&#123; if(x%i==0)&#123; p[++m]=i; c[m]=0; while(x%i==0) x/=i,c[m]++; &#125; &#125; if(x&gt;1) p[++m]=x,c[m]=1;&#125;long long ksm(long long a,long long b) &#123; int c = 1; while(b)&#123; if(b&amp;1) c=c*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return c;&#125;int main()&#123; cin&gt;&gt;a&gt;&gt;b; long long ans=1; divide(a); for(int i=1;i&lt;=m;i++)&#123; if((p[i]-1)%mod==0)&#123; ans=(b*c[i]+1)%mod*ans%mod; &#125; else&#123; long long x=(ksm(p[i],b*c[i]+1)-1+mod)%mod; x*=ksm(p[i]-1,mod-2)%mod; ans=ans*x%mod; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[div3G.Teams]]></title>
    <url>%2F2019%2F04%2F18%2FTeams%2F</url>
    <content type="text"><![CDATA[Codeforces Round #552 (Div. 3) G. Two Teams 题意找到俩个数使他俩的LCM最小,输出这俩个数的下标。 思路 每次枚举每个数的因子,然后求lcm,将最小的LCM的俩个下标存起来。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e7+10;int a[maxn];int v[maxn];int main()&#123; int n; cin&gt;&gt;n; int maxx=0; int ans0=0x3f3f3f3f,ans1=0x3f3f3f3f; long long ma=1e16; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; maxx=max(maxx,a[i]); if(v[a[i]])&#123; long long temp=a[i]; if(ma&gt;temp)&#123; ma=temp; ans0=v[a[i]]; ans1=i; &#125; &#125; v[a[i]]=i; &#125; for(int i=1;i&lt;=maxx;i++)&#123; int ans00=-1,ans11=-1; for(int j=i;j&lt;=maxx;j+=i)&#123; if(v[j])&#123; if(ans00==-1) ans00=j; else ans11=j; &#125; if(ans11!=-1&amp;&amp;ans00!=-1) break; &#125; if(ans11!=-1)&#123; long long temp=1ll*ans11*ans00/i; if(ma&gt;temp)&#123; ma=temp; ans0=v[ans00]; ans1=v[ans11]; &#125; &#125; &#125; if(ans0&gt;ans1) swap(ans0,ans1); printf("%d %d\n",ans0,ans1);&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1091合唱队形]]></title>
    <url>%2F2019%2F04%2F16%2FP1091%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[P1091 合唱队形 题意n位同学站成一排,要求满足所选同学的身高严格单调递增在递减，问最少需要几位同学出列 思路 先正的求一遍LIS，在逆着求一边LIS，最后再求以i(1&lt;=i&lt;=n)为一个转折点求最大的和即为所要求的人（这里要减去1不仅要防止不选还要防止选这一位置俩次），最后在用总数减去这个最大的人数即为所求答案。用贪心加二分的LIS求最长连续子序列，复杂度为o(n). 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100+10;int dp[2][maxn];int a[maxn];int b[maxn];int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; b[1]=a[1]; dp[0][1]=1; int pos=1; for(int i=2;i&lt;=n;i++)&#123; if(a[i]&gt;b[pos]) &#123; pos++; dp[0][i]=pos; b[pos]=a[i]; &#125; else &#123; b[lower_bound(b+1,b+pos+1,a[i])-b]=a[i]; dp[0][i]=pos; &#125; &#125; b[1]=a[n]; dp[1][1]=1; pos=1; for(int i=n-1,j=2;i&gt;=1;i--,j++)&#123; if(a[i]&gt;b[pos]) &#123; pos++; dp[1][j]=pos; b[pos]=a[i]; &#125; else &#123; b[lower_bound(b+1,b+pos+1,a[i])-b]=a[i]; dp[1][j]=pos; &#125; &#125; int maxx=0; for(int i=1;i&lt;=n;i++)&#123; maxx=max(maxx,dp[0][i]+dp[1][n-i+1]-1); &#125; printf("%d\n",n-maxx);&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>LIS</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Median String]]></title>
    <url>%2F2019%2F04%2F15%2F%E6%A8%A1%E6%8B%9F%E6%8B%9F-%E4%B8%AD%E7%AD%89%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Codeforces Round #550 (Div. 3)E. Median String 题意：输入一个n表示一个字符串里面有几个字符，然后寻找这俩个字符串中间的字符。 思路：模拟26位进制数表示 代码：123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+10;int ans[maxn];int main()&#123; int n; cin&gt;&gt;n; string a,b; cin&gt;&gt;a&gt;&gt;b; for(int i=n-1;i&gt;=0;i--)&#123; ans[i]=a[i]-'a'+b[i]-'a'; if(ans[i]&amp;1)&#123; ans[i+1]+=13; ans[i]=ans[i]-1&gt;&gt;1; ans[i]+=ans[i+1]/26; ans[i+1]%=26; &#125; else&#123; ans[i]&gt;&gt;=1; &#125; &#125; for(int i=0;i&lt;n;i++) printf("%c",'a'+ans[i]); cout&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu4576 Robot]]></title>
    <url>%2F2019%2F04%2F14%2F%E6%A6%82%E7%8E%87dp%2F</url>
    <content type="text"><![CDATA[题意​ 在一个环形区域里面分成n个部分，初始在第一个部分(顺时针1到n)，截下来有m次操作，每次可以顺势针或者逆时针走a步问最后走在l到r这个区域内的概率是多少？ 思路 ​ 一道标准的概率dp题，每次走路都由上一步推导而来，只需要将上一步所走的路存起来,最后再把l到r这个区间所有的概率加起来即可。 代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;double dp[2][210];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int n,m,l,r; while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;l&gt;&gt;r&amp;&amp;n+m+l+r)&#123; int t=0; for(int i=0;i&lt;=n;i++) dp[0][i]=0; dp[0][0]=1; while(m--)&#123; int x; cin&gt;&gt;x; for(int i=0;i&lt;n;i++) dp[t^1][i]=0; for(int i=0;i&lt;n;i++)&#123; if(dp[t][i])&#123; dp[t^1][(i+x)%n]+=0.5*dp[t][i]; dp[t^1][(i-x+n)%n]+=0.5*dp[t][i]; &#125; &#125; t^=1; &#125; double ans=0; for(int i=l-1;i&lt;=r-1;i++)&#123; ans+=dp[t][i]; &#125; printf("%.4lf\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>概率dp</category>
      </categories>
      <tags>
        <tag>概率dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论问题之质数]]></title>
    <url>%2F2019%2F04%2F12%2F%E6%95%B0%E8%AE%BA_%E8%B4%A8%E6%95%B0_%E6%95%B0%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[质数定义若一个正整数无法被1和它自身之外的任何自然数整除，则称该数为质数（素数），否则该数为合数。 质数的判定用试除法：1234567bool is_prime(int n)&#123; if(n&lt;2) return false; for(int i=2;i&lt;=sqrt(n);i++)&#123; if(n%i==0) return false; &#125; return true;&#125; 质数的筛选方法：埃式筛法和线性筛法：链接（之前写过，就不写了）。 质因数分解算术基本定理： 任何一个不大于1的正整数都能唯一分解为有限个质数的乘积，可写作 N=p_1^c1*p_2^c2*p_3^c3*……p_m^cm​ 其中ci为正整数，pi为质数，满足p1]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>质数</tag>
      </tags>
  </entry>
</search>
