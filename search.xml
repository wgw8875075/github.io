<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法作业一]]></title>
    <url>%2F2019%2F04%2F24%2F%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[归并排序1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;const int maxn=1e5+10;int tmp[maxn];int a[maxn];void merge( int start, int mid, int end)&#123; int i = start; int j = mid + 1; int k = 0; while(i &lt;= mid &amp;&amp; j &lt;= end)&#123; if (a[i] &lt;= a[j]) tmp[k++] = a[i++]; else tmp[k++] = a[j++]; &#125; while(i &lt;= mid) tmp[k++] = a[i++]; while(j &lt;= end) tmp[k++] = a[j++]; for (i = 0; i &lt; k; i++) a[start + i] = tmp[i];&#125;void mergeSort( int start, int end)&#123; if(start &gt;= end) return ; int mid = (end + start)/2; mergeSort( start, mid); mergeSort( mid+1, end); merge(start, mid, end);&#125;int main()&#123; int n; cin&gt;&gt;n; for (int i=1; i&lt;=n; i++) cin&gt;&gt;a[i]; mergeSort(1, n); for (int i=1; i&lt;=n; i++) cout &lt;&lt; a[i] &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; 棋盘覆盖123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e4+10;int m[maxn][maxn];int n=0;void chessboard(int x,int y,int tx,int ty,int s)&#123; if(s==1) return; s&gt;&gt;=1; int t=++n; if(tx&lt;=x+s-1&amp;&amp;ty&lt;=y+s-1) chessboard(x,y,tx,ty,s); else m[x+s-1][y+s-1]=t,chessboard(x,y,x+s-1,y+s-1,s); if(tx&lt;=x+s-1&amp;&amp;ty&gt;=y+s) chessboard(x,y+s,tx,ty,s); else m[x+s-1][y+s]=t,chessboard(x,y+s,x+s-1,y+s,s); if(tx&gt;=x+s&amp;&amp;ty&lt;=y+s-1) chessboard(x+s,y,tx,ty,s); else m[x+s][y+s-1]=t,chessboard(x+s,y,x+s,y+s-1,s); if(tx&gt;=x+s&amp;&amp;ty&gt;=y+s) chessboard(x+s,y+s,tx,ty,s); else m[x+s][y+s]=t,chessboard(x+s,y+s,x+s,y+s,s);&#125;int main()&#123; while(true)&#123; int size; cin&gt;&gt;size; int x,y; cin&gt;&gt;x&gt;&gt;y; chessboard(1,1,x,y,size); for(int i=1;i&lt;=size;i++)&#123; for(int j=1;j&lt;=size;j++)&#123; printf("%3d ",m[i][j]); &#125; printf("\n"); &#125; &#125;&#125; 循环日程表12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int n,half=1,k=1;int pic[100][100];int main()&#123; cin&gt;&gt;n; pic[0][0]=1; int m=1&lt;&lt;n; while(k&lt;=n)&#123; for(int i=0;i&lt;half;i++)&#123; for(int j=0;j&lt;half;j++)&#123; pic[i][j+half]=pic[i][j]+half; &#125; &#125; for(int i=0;i&lt;half;i++)&#123; for(int j=0;j&lt;half;j++)&#123; pic[i+half][j]=pic[i][j+half]; pic[i+half][j+half]=pic[i][j]; &#125; &#125; half*=2; k++; &#125; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;m;j++)&#123; printf("%3d",pic[i][j]); &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 快速排序1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;int a[maxn];void quicksort(int left,int right)&#123; if(left&gt;right) return ; int temp=a[left]; int i=left; int j=right; while(i!=j)&#123; while(a[j]&gt;=temp&amp;&amp;i&lt;j) j--; while(a[i]&lt;=temp&amp;&amp;i&lt;j) i++; if(i&lt;j)&#123; int t=a[i]; a[i]=a[j]; a[j]=t; &#125; &#125; a[left]=a[i]; a[i]=temp; quicksort(left,i-1); quicksort(i+1,right);&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; quicksort(1,n); for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;" "; puts(""); return 0;&#125;]]></content>
      <categories>
        <category>二分</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ST算法]]></title>
    <url>%2F2019%2F04%2F22%2FST%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[介绍RMQ (Range Minimum/Maximum Query)问题是指：对于长度为n的数列A，回答若干询问RMQ(A,i,j)(i,j&lt;=n)，返回数列A中下标在i,j里的最小(大）值，也就是说，RMQ问题是指求区间最值的问题。 ​ ST算法就是倍增的产物，ST算法能在O(nlogN)的预处理后，以O(1)的时间求出区间最值问题(当然也能求出其他问题)。思想上类似于动态规划，每次从上一次转移(状态转移方程看下面)。 思路​ 数列A是一个二维数组，A[i] [j]表示从第i个数字起长度为2的j次方的最大值。每次都成倍增长，公式 F[i,j]=max(F[i][j-1],F[i+2的(j-1)次方][j-1])长度为2的j次方的最大值是左右俩半长度为2的j-1次方的子区间中较大的一个。 代码预处理函数 123456789void ST()&#123; for(int i=1;i&lt;=n;i++) f[i][0]=a[i]; int t=log(n)/log(2)+1; for(int j=1;j&lt;t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125;&#125; 查询函数 1234int ST_query(int l,int r)&#123; int k=log(r-l+1)/log(2); return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125; 例题P3865 【模板】ST表 代码12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int n,m;int f[maxn][50];int a[maxn];void ST()&#123; for(int i=1;i&lt;=n;i++) f[i][0]=a[i]; int t=log(n)/log(2)+1; for(int j=1;j&lt;t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125;&#125;int ST_query(int l,int r)&#123; int k=log(r-l+1)/log(2); return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; ST(); for(int i=1;i&lt;=m;i++)&#123; int l,r; cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;ST_query(l,r)&lt;&lt;"\n"; &#125; system("pause");&#125;]]></content>
      <categories>
        <category>RMQ</category>
      </categories>
      <tags>
        <tag>RMQ</tag>
        <tag>ST算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长上升子序列LIS]]></title>
    <url>%2F2019%2F04%2F18%2F%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97(LIS)%2F</url>
    <content type="text"><![CDATA[介绍最长上升子序列问题，也就是Longest increasing subsequence，缩写为LIS。是指在一个序列中求长度最长的一个上升子序列的问题，是动态规划中一个相当经典问题。在这里我们可以看到，这个上升实质上就是一个对&lt;进行定义的过程，所以我们求解的其实是一类问题，也就是在给定序列中求解长度最长的符合某一性质的子序列的问题。 解法一状态设计：F[i]代表以A[i]结尾的LIS的长度状态转移：F[i]=max{F[j]+1}(1&lt;=j&lt; i,A[j]&lt; A[i])边界处理：F[i]=1(1&lt;=i&lt;=n)时间复杂度：O(n^2)PS(理解dp最简单的方法：画表，自行推理) 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int a[maxn],dp[maxn];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); dp[i]=1; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;i;j++)&#123; if(a[j]&lt;a[i]) dp[i]=max(dp[i],dp[j]+1); &#125; &#125; int maxx=0; for(int i=1;i&lt;=n;i++) maxx=max(maxx,dp[i]); printf("%d\n",maxx); return 0; &#125; 解法二贪心加二分 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;const int INF=0x7f7f7f7f;int a[maxn],dp[maxn];int binary_search(int l,int r,int x)&#123;//二分查找第一个大于等于x的元素 while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(dp[mid]&lt;=x) l=mid+1; else r=mid-1; &#125; return l;&#125;int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); dp[i]=INF;//初始化为无穷大 &#125; int pos=1; dp[1]=a[1]; for(int i=2;i&lt;=n;i++)&#123; if(a[i]&gt;dp[pos]) dp[++pos]=a[i];// else dp[lower_bound(dp+1,dp+pos+1,a[i])-dp]=a[i];//lower_bound(a,a+n,x)函数 返回从数组a到a+n中第一个&gt;=x的元素地址 else dp[binary_search(1,pos,a[i])]=a[i];//也可以自己写二分查找。 &#125; printf("%d\n",pos); return 0;&#125; 解法三用树状数组维护，降低复杂度。PS(我写完后发现这个方法将相等的也计算在其中)。不知道有没有人能去除掉相等，是我太菜了，QWQ.维护每个数的序列也就是第几个数，然后查询其前面的最长上升子序列，然后更新其后的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int n,dp[maxn];struct point&#123; int x,id; bool operator &lt; (const point &amp;a) const&#123; return x&lt;a.x||(a.x==x&amp;&amp;a.id&gt;id); &#125;&#125;;int lowbit(int x)&#123; return x&amp;(-x);&#125;int query(int x)&#123; int sum=0; while(x)&#123; sum=max(sum,dp[x]); x-=lowbit(x); &#125; return sum;&#125;void modify(int x,int y)&#123; while(x&lt;=n)&#123; dp[x]=max(dp[x],y); x+=lowbit(x); &#125;&#125;point a[maxn];int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i].x); a[i].id=i; &#125;// for(int i=1;i&lt;=n;i++) printf("%d %d\n",a[i].x,a[i].id);// printf("\n"); sort(a+1,a+n+1);// for(int i=1;i&lt;=n;i++) printf("%d %d\n",a[i].x,a[i].id); int ans=0; for(int i=1;i&lt;=n;i++)&#123; int maxx=query(a[i].id); modify(a[i].id,++maxx); ans=max(ans,maxx); &#125; printf("%d\n",ans); return 0;&#125; 解法四随后我查了相关的博客后，发现换个思维就可以排除相等的情况。即维护每一个刚输入的值，查询其前面的最长的上升子序列。 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int n,dp[maxn];int lowbit(int x)&#123; return x&amp;(-x);&#125;int query(int x)&#123; int sum=0; while(x)&#123; sum=max(sum,dp[x]); x-=lowbit(x); &#125; return sum;&#125;void modify(int x,int y)&#123; while(x&lt;=maxn)&#123; dp[x]=max(dp[x],y); x+=lowbit(x); &#125;&#125;int main()&#123; scanf("%d",&amp;n); int ans=0; for(int i=1;i&lt;=n;i++)&#123; int x; scanf("%d",&amp;x); x++;//因为树状数组从1开始，每次查询x-1以及前面的最大值 int maxx=query(x-1)+1; ans=max(ans,maxx); modify(x,maxx); &#125; printf("%d\n",ans);&#125; 不过解法三和四都有一定的局限性，只能所有数都是&gt;=1的正整数时才能用，不过这种思维可以用在好多地方。如果存在负数的情况，用方法二是最好的。]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>LIS</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj1845sumdiv]]></title>
    <url>%2F2019%2F04%2F18%2Fsumdiv%2F</url>
    <content type="text"><![CDATA[poj1845 sumdiv 题意求$A^B$的所有约束之和mod9901. 思路​ A可以写成 p_1^c1*p_2^c2*……*p_n^cn​ 然后 A^B可以写成p_1^c1^B*p_2^c2*B*……*p_n^cn*^B 然后A^B的约数可以写成 (1+p_1+p_1^2+……+p_1^c1^B)*(1+p_2+p_2^2+……+p_2^c2*B)*…… *(1+p_n+p_n^2+……+p_n^cn*^B)而等比数列的公式可以写成 (p_1^b*^c_1+1)/(p_1+1) (p_1-1)不是9901的倍数时可以用逆元求出但当(p_1-1)是9901的倍数时，无法求逆元 这时p_1模除9901时余1这时带入(1+p_i+p_i^2+……+p_i^ci*B)得到B*c_1+1这样问题就得以解决。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;const int mod=9901;int a,b;int p[20],c[20];int m=0;void divide(int x)&#123; for(int i=2;i*i&lt;=x;i++)&#123; if(x%i==0)&#123; p[++m]=i; c[m]=0; while(x%i==0) x/=i,c[m]++; &#125; &#125; if(x&gt;1) p[++m]=x,c[m]=1;&#125;long long ksm(long long a,long long b) &#123; int c = 1; while(b)&#123; if(b&amp;1) c=c*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return c;&#125;int main()&#123; cin&gt;&gt;a&gt;&gt;b; long long ans=1; divide(a); for(int i=1;i&lt;=m;i++)&#123; if((p[i]-1)%mod==0)&#123; ans=(b*c[i]+1)%mod*ans%mod; &#125; else&#123; long long x=(ksm(p[i],b*c[i]+1)-1+mod)%mod; x*=ksm(p[i]-1,mod-2)%mod; ans=ans*x%mod; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[div3G.Teams]]></title>
    <url>%2F2019%2F04%2F18%2FTeams%2F</url>
    <content type="text"><![CDATA[Codeforces Round #552 (Div. 3) G. Two Teams 题意找到俩个数使他俩的LCM最小,输出这俩个数的下标。 思路 每次枚举每个数的因子,然后求lcm,将最小的LCM的俩个下标存起来。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e7+10;int a[maxn];int v[maxn];int main()&#123; int n; cin&gt;&gt;n; int maxx=0; int ans0=0x3f3f3f3f,ans1=0x3f3f3f3f; long long ma=1e16; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; maxx=max(maxx,a[i]); if(v[a[i]])&#123; long long temp=a[i]; if(ma&gt;temp)&#123; ma=temp; ans0=v[a[i]]; ans1=i; &#125; &#125; v[a[i]]=i; &#125; for(int i=1;i&lt;=maxx;i++)&#123; int ans00=-1,ans11=-1; for(int j=i;j&lt;=maxx;j+=i)&#123; if(v[j])&#123; if(ans00==-1) ans00=j; else ans11=j; &#125; if(ans11!=-1&amp;&amp;ans00!=-1) break; &#125; if(ans11!=-1)&#123; long long temp=1ll*ans11*ans00/i; if(ma&gt;temp)&#123; ma=temp; ans0=v[ans00]; ans1=v[ans11]; &#125; &#125; &#125; if(ans0&gt;ans1) swap(ans0,ans1); printf("%d %d\n",ans0,ans1);&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1091合唱队形]]></title>
    <url>%2F2019%2F04%2F16%2FP1091%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[P1091 合唱队形 题意n位同学站成一排,要求满足所选同学的身高严格单调递增在递减，问最少需要几位同学出列 思路 先正的求一遍LIS，在逆着求一边LIS，最后再求以i(1&lt;=i&lt;=n)为一个转折点求最大的和即为所要求的人（这里要减去1不仅要防止不选还要防止选这一位置俩次），最后在用总数减去这个最大的人数即为所求答案。用贪心加二分的LIS求最长连续子序列，复杂度为o(n). 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100+10;int dp[2][maxn];int a[maxn];int b[maxn];int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; b[1]=a[1]; dp[0][1]=1; int pos=1; for(int i=2;i&lt;=n;i++)&#123; if(a[i]&gt;b[pos]) &#123; pos++; dp[0][i]=pos; b[pos]=a[i]; &#125; else &#123; b[lower_bound(b+1,b+pos+1,a[i])-b]=a[i]; dp[0][i]=pos; &#125; &#125; b[1]=a[n]; dp[1][1]=1; pos=1; for(int i=n-1,j=2;i&gt;=1;i--,j++)&#123; if(a[i]&gt;b[pos]) &#123; pos++; dp[1][j]=pos; b[pos]=a[i]; &#125; else &#123; b[lower_bound(b+1,b+pos+1,a[i])-b]=a[i]; dp[1][j]=pos; &#125; &#125; int maxx=0; for(int i=1;i&lt;=n;i++)&#123; maxx=max(maxx,dp[0][i]+dp[1][n-i+1]-1); &#125; printf("%d\n",n-maxx);&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>LIS</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Median String]]></title>
    <url>%2F2019%2F04%2F15%2F%E6%A8%A1%E6%8B%9F%E6%8B%9F-%E4%B8%AD%E7%AD%89%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Codeforces Round #550 (Div. 3)E. Median String 题意：输入一个n表示一个字符串里面有几个字符，然后寻找这俩个字符串中间的字符。 思路：模拟26位进制数表示 代码：123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+10;int ans[maxn];int main()&#123; int n; cin&gt;&gt;n; string a,b; cin&gt;&gt;a&gt;&gt;b; for(int i=n-1;i&gt;=0;i--)&#123; ans[i]=a[i]-'a'+b[i]-'a'; if(ans[i]&amp;1)&#123; ans[i+1]+=13; ans[i]=ans[i]-1&gt;&gt;1; ans[i]+=ans[i+1]/26; ans[i+1]%=26; &#125; else&#123; ans[i]&gt;&gt;=1; &#125; &#125; for(int i=0;i&lt;n;i++) printf("%c",'a'+ans[i]); cout&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu4576 Robot]]></title>
    <url>%2F2019%2F04%2F14%2F%E6%A6%82%E7%8E%87dp%2F</url>
    <content type="text"><![CDATA[题意​ 在一个环形区域里面分成n个部分，初始在第一个部分(顺时针1到n)，截下来有m次操作，每次可以顺势针或者逆时针走a步问最后走在l到r这个区域内的概率是多少？ 思路 ​ 一道标准的概率dp题，每次走路都由上一步推导而来，只需要将上一步所走的路存起来,最后再把l到r这个区间所有的概率加起来即可。 代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;double dp[2][210];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int n,m,l,r; while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;l&gt;&gt;r&amp;&amp;n+m+l+r)&#123; int t=0; for(int i=0;i&lt;=n;i++) dp[0][i]=0; dp[0][0]=1; while(m--)&#123; int x; cin&gt;&gt;x; for(int i=0;i&lt;n;i++) dp[t^1][i]=0; for(int i=0;i&lt;n;i++)&#123; if(dp[t][i])&#123; dp[t^1][(i+x)%n]+=0.5*dp[t][i]; dp[t^1][(i-x+n)%n]+=0.5*dp[t][i]; &#125; &#125; t^=1; &#125; double ans=0; for(int i=l-1;i&lt;=r-1;i++)&#123; ans+=dp[t][i]; &#125; printf("%.4lf\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>概率dp</category>
      </categories>
      <tags>
        <tag>概率dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论问题之质数]]></title>
    <url>%2F2019%2F04%2F12%2F%E6%95%B0%E8%AE%BA_%E8%B4%A8%E6%95%B0_%E6%95%B0%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[质数定义若一个正整数无法被1和它自身之外的任何自然数整除，则称该数为质数（素数），否则该数为合数。 质数的判定用试除法：1234567bool is_prime(int n)&#123; if(n&lt;2) return false; for(int i=2;i&lt;=sqrt(n);i++)&#123; if(n%i==0) return false; &#125; return true;&#125; 质数的筛选方法：埃式筛法和线性筛法：链接（之前写过，就不写了）。 质因数分解算术基本定理： 任何一个不大于1的正整数都能唯一分解为有限个质数的乘积，可写作 N=p_1^c1*p_2^c2*p_3^c3*……p_m^cm​ 其中ci为正整数，pi为质数，满足p1]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>质数</tag>
      </tags>
  </entry>
</search>
