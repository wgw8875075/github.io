<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算几何模板]]></title>
    <url>%2F2019%2F08%2F25%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;//floor(x) 向下取整函数//ceil(x) 向上取整函数//round(x) 四舍五入函数struct Point&#123; double x,y; Point(double x=0,double y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码编写&#125;;typedef Point Vector;//向量+向量=向量 向量+点=点Vector operator + (Vector A,Vector B)&#123; return Vector(A.x+B.x,A.y+B.y);&#125;//点-点=向量Vector operator - (Point A,Point B)&#123; return Vector(A.x-B.x,A.y-B.y);&#125;//向量*数=向量Vector operator * (Vector A,double p)&#123; return Vector(A.x*p,A.y*p);&#125;//向量/数=向量Vector operator / (Vector A,double p)&#123; return Vector(A.x/p,A.y/p);&#125;bool operator &lt; (const Point&amp; a,const Point&amp; b)&#123; return a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y);&#125;const double eps=1e-10;int dcmp(double x)&#123;//精度问题 if(fabs(x)&lt;eps) return 0; else return x&lt;0?-1:1;&#125;bool operator ==(const Point&amp; a,const Point&amp; b)&#123; return dcmp(a.x-b.x)==0&amp;&amp;dcmp(a.y-b.y)==0;&#125;//点积double Dot(Vector A,Vector B)&#123; return A.x*B.x+A.y*B.y;&#125;//向量长度double Length(Vector A)&#123; return sqrt(Dot(A,A));&#125;//向量夹角double Angle(Vector A,Vector B)&#123; return acos(Dot(A,B)/Length(A)/Length(B));&#125;//叉积：计算三角形有向面积的2倍（叉积cross(v,w)）w在v的左边叉积大于0，否则小于0 共线等于0double Cross(Vector A,Vector B)&#123; return A.x*B.y-A.y*B.x;&#125;//三点形成的面积double Area2(Point A,Point B,Point C)&#123; return Cross(B-A,C-A);&#125;//rad是弧度Vector Rotate(Vector A,double rad)&#123; return (A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125;//计算向量的单位法向量Vector Normal(Vector A)&#123; double L=Length(A); return Vector(-A.y/L,A.x/L);&#125;//利用三角形相似得证俩个直线得交点Point GetLineIntersection(Point P,Vector v,Point Q,Vector w)&#123; Vector u=P-Q; double t=Cross(w,u)/Cross(v,w); return P+v*t;&#125;//点到直线得距离double DistanceToLine(Point P,Point A,Point B)&#123; Vector v1=B-A,v2=P-A; return fabs(Cross(v1,v2))/Length(v1);//取绝对值是无向距离，不取有向距离&#125;//点到线段得距离double DistanceToSegment(Point P,Point A,Point B)&#123; if(A==B) return Length(P-A); Vector v1=A-B,v2=P-A,v3=P-B; if(dcmp(Dot(v1,v2))&lt;0) return Length(v2); else if(dcmp(Dot(v1,v3))&gt;0) return Length(v3); else return fabs(Cross(v1,v2))/Length(v1);&#125;//求点P在直线A-&gt;B得投影Point GetLineProjection(Point P,Point A,Point B)&#123; Vector v=B-A; return A+v*(Dot(v,P-A)/Dot(v,v));&#125;//求俩线段是否相交(不包括端点)bool SegmentProperIntersection(Point a1,Point a2,Point b1,Point b2)&#123; double c1=Cross(a2-a1,b1-a1),c2=Cross(a2-a1,b2-a1); double c3=Cross(b2-b1,a1-b1),c4=Cross(b2-b1,a2-b1); return dcmp(c1)*dcmp(c2)&lt;=0&amp;&amp;dcmp(c3)*dcmp(c4)&lt;=0;&#125;bool OnSegment(Point P,Point a1,Point a2)&#123; return dcmp(Cross(a1-p,a2-p))==0&amp;&amp;dcmp(Dot(a1-p,a2-p))&lt;0;&#125;int main()&#123; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客多校第六场]]></title>
    <url>%2F2019%2F08%2F04%2F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%85%AD%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[D Move题意 要把n个物品放到k个盒子里,每个物品都有一个体积,每次找与这个盒子最接近的体积放进去,直到放不下,然后去放下一个盒子直到放完,求盒子最小的体积. 思路显然这个题每个不能二分体积,然后暴力找体积范围为[ceil(sum/k),ceil(sum/k)+maxV] ,sum是所有物品的总体积,maxV是最大的体积,对于每个体积在按题意模拟即可. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e3+10;int a[maxn];int n,m,k;bool check(int mid)&#123; multiset&lt;int&gt; s; for (int i = 1; i &lt;= n; i++) s.insert(a[i]); for (int i = 1; i &lt;= k; i++)&#123; int lst=mid; auto it=s.upper_bound(lst); while(it!=s.begin())&#123; lst-=*(--it); s.erase(it); it=s.upper_bound(lst); &#125; &#125; if (s.empty()) return true; return false;&#125;int main()&#123; int _; while(~scanf("%d",&amp;_))&#123; int id=0; while(_--)&#123; scanf("%d%d",&amp;n,&amp;m); int maxx=0; int sum=0; k=m; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); maxx=max(a[i],maxx); sum+=a[i]; &#125; int ans=ceil(1.0*sum/m); for(int i=ceil(1.0*sum/m);i&lt;=ceil(sum/m)+maxx;i++)&#123; if(check(i)) &#123; ans=i; break; &#125; &#125; printf("Case #%d: %d\n",++id,ans); &#125; &#125;&#125; J Upgrading Technology题意有i个技术初始为0级,可升最高等级为j级,第i个技术j-1级时升一级消费$c_{ij}$当所有物品升到同一级时会有$d_j$的利润,问最大的利润是多少. 思路记录后缀最小然后依次比较就行了. 思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e3 + 10;ll a[maxn][maxn];ll b[maxn][maxn];ll d[maxn];int main()&#123; int _; while (~scanf("%d", &amp;_))&#123; int id = 0; while (_--)&#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++)&#123; a[i][0]=0; for (int j = 1; j &lt;= m; j++)&#123; scanf("%lld", &amp;a[i][j]); a[i][j] += a[i][j - 1]; b[i][j] = a[i][j]; &#125; &#125; for (int i = n; i &gt;= 1; i--)&#123; for (int j = m - 1; j &gt;= 0; j--)&#123; a[i][j] = min(a[i][j], a[i][j + 1]); &#125; &#125; for (int i = 1; i &lt;= m; i++)&#123; scanf("%lld", &amp;d[i]); d[i] += d[i - 1]; &#125; ll ans = 0; for (int i = 0; i &lt;= m; i++)&#123; ll anss = 0; for (int j = 1; j &lt;= n; j++)&#123; anss += a[j][i]; &#125; ll an = 1e18; for (int j = 1; j &lt;= n; j++)&#123; an = min(an, anss - a[j][i] + b[j][i]); &#125; ans = max(ans, d[i] - an); &#125; printf("Case #%d: %lld\n", ++id, ans); &#125; &#125; //system("pause");&#125;]]></content>
      <categories>
        <category>牛客多校</category>
      </categories>
      <tags>
        <tag>牛客多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu多校第二场]]></title>
    <url>%2F2019%2F08%2F02%2Fhdu%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%8C%E5%9C%BA%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[hdu多校第一场]]></title>
    <url>%2F2019%2F08%2F02%2Fhdu%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA%2F</url>
    <content type="text"></content>
      <categories>
        <category>hdu多校</category>
      </categories>
      <tags>
        <tag>hdu多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu多校第三场]]></title>
    <url>%2F2019%2F08%2F02%2Fhdu%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[hdu多校第四场]]></title>
    <url>%2F2019%2F08%2F02%2Fhdu%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[B xor题意有n个基合每个集合都有小于等于32个数,有m个查询,每个查询为l,r,x,代表l~r区间内,是否每个集合都可以独立表示x这个数. 思路用线段树维护区间内的线性基交,然后查询区间线性基是否可以表示x. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;# define ls (pos&lt;&lt;1)# define rs ((pos&lt;&lt;1)|1)const int maxn=5e4+10;unsigned tree[maxn&lt;&lt;2][32];void insert(unsigned x,int pos)&#123; for(int i=31;i&gt;=0;i--) if(x&gt;&gt;i)&#123; if(!tree[pos][i])&#123; tree[pos][i]=x; break; &#125; x^=tree[pos][i]; &#125;&#125;void push_up(int pos)&#123; int l=ls,r=rs; unsigned t1[32],t2[32]; for(int i=0;i&lt;=31;i++) t1[i]=t2[i]=tree[l][i]; for(int i=0;i&lt;=31;i++) if(tree[r][i])&#123; unsigned x=tree[r][i],tmp=0; for(int j=31;j&gt;=0;j--) if(x&gt;&gt;j)&#123; if(!t1[j])&#123; t1[j]=x; t2[j]=tmp; break; &#125; x^=t1[j]; tmp^=t2[j]; &#125; if(!x) insert(tmp,pos); &#125;&#125;void build(int l,int r,int pos)&#123; if(l==r)&#123; int c; scanf("%d",&amp;c); for(int i=1;i&lt;=c;i++)&#123; unsigned x; scanf("%u",&amp;x); insert(x,pos); &#125; return ; &#125; int mid=(l+r)&gt;&gt;1; build(l,mid,ls); build(mid+1,r,rs); push_up(pos);&#125;int query(int x,int y,unsigned int val,int l, int r,int pos)&#123; if(l&gt;=x&amp;&amp;y&gt;=r)&#123; for(int i=31;i&gt;=0;i--) if(val&gt;&gt;i) val^=tree[pos][i]; return val==0; &#125; int mid=l+r&gt;&gt;1; int res=1; if(x&lt;=mid) res&amp;=query(x,y,val,l,mid,ls); if(y&gt;mid) res&amp;=query(x,y,val,mid+1,r,rs); return res;&#125;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); build(1,n,1); for(int i=1;i&lt;=m;i++)&#123; int x,y; unsigned val; scanf("%d%d%u",&amp;x,&amp;y,&amp;val); printf("%s\n",query(x,y,val,1,n,1)?"YES":"NO"); &#125; //system("pause");&#125;]]></content>
      <categories>
        <category>牛客多校</category>
      </categories>
      <tags>
        <tag>牛客多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客多校第五场]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[A digits 2签到题 B generator 1题意 求x_{i}=ax_{i-1}+bx_{x-2}(mod MOD),i≥2,1≤n]]></content>
      <categories>
        <category>牛客多校</category>
      </categories>
      <tags>
        <tag>牛客多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1100F-Ivan and Burgers]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%BA%BF%E6%80%A7%E5%9F%BA%2F</url>
    <content type="text"><![CDATA[F. Ivan and Burgers 题意​ 给出n个整数,有q次查询,每次查询给出l,r,问l,r内区间的最大异或和. 思路 线性基,在线或者离线 代码离线线性基的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e5+10;int a[maxn],ans[maxn];struct P&#123; int l,r,id; bool operator &lt; (P b)&#123; return r&lt;b.r; &#125;&#125; p[maxn];int pos[21],line[21];void add(int x,int id)&#123; for(int i=20;i&gt;=0;i--)&#123; if(x&amp;(1&lt;&lt;i))&#123; if(!line[i]) &#123; line[i]=x,pos[i]=id; break; &#125; if(pos[i]&lt;id) swap(line[i],x),swap(pos[i],id); x^=line[i]; &#125; &#125;&#125;int query(int id)&#123; int res=0; for(int i=20;i&gt;=0;i--)&#123; if(pos[i]&gt;=id&amp;&amp;(res^line[i])&gt;res) res^=line[i]; &#125; return res;&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; int q; cin&gt;&gt;q; for(int i=1;i&lt;=q;i++)&#123; cin&gt;&gt;p[i].l&gt;&gt;p[i].r; p[i].id=i; &#125; sort(p+1,p+q+1); int l=1; for(int i=1;i&lt;=q;i++)&#123; while(l&lt;=p[i].r&amp;&amp;l&lt;=n) add(a[l],l),l++; ans[p[i].id]=query(p[i].l); &#125; for(int i=1;i&lt;=q;i++) printf("%d\n",ans[i]); //system("pause"); return 0;&#125; 在线线性基的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e5+10;int a[maxn],pos[maxn][21],line[maxn][21];struct P&#123; int l,r,id;&#125;p[maxn];int n;void init()&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;=20;j++) line[i][j]=line[i-1][j],pos[i][j]=pos[i-1][j]; int id=i; for(int j=20;j&gt;=0;j--)&#123; if(a[i]&amp;(1&lt;&lt;j))&#123; if(!line[i][j]) &#123; line[i][j]=a[i]; pos[i][j]=id; break; &#125; if(pos[i][j]&lt;id) swap(line[i][j],a[i]),swap(pos[i][j],id); a[i]^=line[i][j]; &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); init(); int q; scanf("%d",&amp;q); for(int i=1;i&lt;=q;i++)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); int res=0; for(int j=20;j&gt;=0;j--) if(pos[r][j]&gt;=l&amp;&amp;(res^line[r][j])&gt;res) res^=line[r][j]; printf("%d\n",res); &#125; //system("pause");&#125;]]></content>
      <categories>
        <category>线性基</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校第一场]]></title>
    <url>%2F2019%2F07%2F19%2F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%2F</url>
    <content type="text"><![CDATA[感谢老陈的翻译 B. Integration题目大意 已知\int_0^{\infty}\frac{1}{1+x^2}dx=\frac{\pi}{2}.给定数组a,求\frac{1}{\pi}\int_0^{\infty}\frac{1}{\prod{\left( a_i^2+x^2 \right) }}dx的值. 假设结果为\frac{p}{q},输出p \cdot q^{-1}.思路先把所给公式分母下面的公式拿出来化简 \frac{1}{\prod_{i=1}^{n}\left( a_{i}^2+x^2\right )} \begin{align}&\frac{1}{\prod_{i=1}^{n}\left( a_{i}^2+x^2\right )}\\ =&\frac{1}{\left(a_1^2+x^2\right) \left(a_2^2+x^2\right) }\times \frac{1}{\prod_{i=3}^{n}\left( a_{i}^2+x^2\right )} \\ =& \frac{1}{ a_2^2-a_1^2 }\times \left( \frac{1}{a_1^2+x^2}- \frac{1}{a_2^2+x^2 }\right)\times \frac{1} {\prod_{i=3}^{n}\left( a_{i}^2+x^2 \right)}\\ =& \frac{1}{ a_2^2-a_1^2 }\times \left( \frac{1}{a_1^2+x^2}\times\frac{1}{a_3^2+x^2}- \frac{1}{a_2^2+x^2 }\times\frac{1}{a_3^2+x^2}\right)\times \frac{1} {\prod_{i=4}^{n}\left( a_{i}^2+x^2 \right)}\\ =& \left(\frac{1}{(a_2^2-a_1^2)(a_3^2-a_1^2)}\frac{1}{(a_1^2+x^2)}+\frac{1}{(a_1^2-a_2^2)(a_3^2-a_2^2)}\frac{1}{(a_2^2+x^2)}+\frac{1}{(a_1^2-a_3^2)(a_2^2-a_3^2)}\frac{1}{(a_3^2+x^2)} \right )\times \frac{1} {\prod_{i=4}^{n}\left( a_{i}^2+x^2 \right)} \end{align}然后总结公式继续化简 \begin{aligned} &\sum\limits_{i=1}^{n}\frac{1}{\prod\limits_{j=1,j\not=i}^{n}(a_j^2-a_i^2)}\int_0^{\infty}\frac{1}{a_i^2+x^2}dx&\\ =&\sum\limits_{i=1}^{n}\frac{1}{\prod\limits_{j=1,j\not=i}^{n}(a_j^2-a_i^2)\times a_i^2}\int_0^{\infty}\frac{1}{1+(\frac{x}{a_i})^2}dx&\\ =&\sum\limits_{i=1}^{n}\frac{1}{\prod\limits_{j=1,j\not=i}^{n}(a_j^2-a_i^2)\times a_i}\int_0^{\infty}\frac{1}{1+(\frac{x}{a_i})^2}d\left(\frac{x}{a_i}\right)\\ = &\sum\limits_{i=1}^{n}\frac{1}{2\times\prod\limits_{j=1,j\not=i}^{n}(a_j^2-a_i^2)\times a_i}\end{aligned}感谢瓜皮大佬hhh 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1010;const int mod=1e9+7;ll a[maxn];ll quickMod(ll a, ll p, ll mod) &#123; a%=mod; ll base=1; while(p) &#123; if(p&amp;1) base=base*a%mod; a=a*a%mod; p&gt;&gt;=1; &#125; return base;&#125;int main()&#123; int n; while(~scanf("%d",&amp;n))&#123; for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); &#125; ll ans=0; for(int i=1;i&lt;=n;i++)&#123; ll temp=1; for(int j=1;j&lt;=n;j++)&#123; if(i!=j) temp=temp*((a[j]*a[j]%mod-a[i]*a[i]%mod)%mod+mod)%mod; &#125; temp=quickMod(temp,mod-2,mod); temp=temp*quickMod(2*a[i],mod-2,mod)%mod; ans=(ans+temp)%mod; &#125; printf("%lld\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几何题小测]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%87%A0%E4%BD%95%E9%A2%98%E5%B0%8F%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[POJ2007 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct Point &#123; int x,y;&#125;a[100];typedef Point Vector;int cross(Vector a,Vector b)&#123; return a.x*b.y-a.y*b.x;&#125;bool cmp(Vector a,Vector b)&#123; return cross(a,b)&gt;=0;&#125;int main()&#123; int x,y; int tot=0; while(~scanf("%d%d",&amp;x,&amp;y))&#123; a[++tot].x=x; a[tot].y=y; &#125; sort(a+2,a+tot+1,cmp); for(int i=1;i&lt;=tot;i++)&#123; printf("(%d,%d)\n",a[i].x,a[i].y); &#125; //system("pause");&#125; POJ2624 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;struct Point &#123; double x,y; Point(double x=0,double y=0):x(x),y(y)&#123;&#125;&#125;a[100];typedef Point Vector;Vector operator - (Point A,Point B)&#123; return Vector(A.x-B.x,A.y-B.y);&#125;Vector operator + (Vector A,Vector B)&#123; return Vector(A.x+B.x,A.y+B.y);&#125;const double eps=1e-10;// int dcmp(double x)&#123;//精度问题// if(fabs(x)&lt;eps) return 0;// else return x&lt;0?-1:1;// &#125;bool operator ==(const Point&amp; a,const Point&amp; b)&#123; return (a.x-b.x)==0&amp;&amp;(a.y-b.y)==0;&#125;int main()&#123; while(~scanf("%lf%lf%lf%lf%lf%lf%lf%lf",&amp;a[1].x,&amp;a[1].y,&amp;a[2].x,&amp;a[2].y,&amp;a[3].x,&amp;a[3].y,&amp;a[4].x,&amp;a[4].y))&#123; Point ans; if(a[1]==a[3])&#123; ans=a[2]-a[1]+a[4]-a[1]+a[1]; &#125; else if(a[1]==a[4])&#123; ans=a[2]-a[1]+a[3]-a[1]+a[1]; &#125; else if(a[2]==a[3])&#123; ans=a[1]-a[2]+a[4]-a[2]+a[2]; &#125; else if(a[2]==a[4])&#123; ans=a[1]-a[2]+a[3]-a[2]+a[2]; &#125; printf("%.3lf %.3lf\n",ans.x,ans.y); &#125;&#125; POJ1569 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;int n;struct Point &#123; double x,y; Point(double x=0,double y=0):x(x),y(y)&#123;&#125;&#125;a[100];typedef Point Vector;Vector operator - (Point A,Point B)&#123; return Vector(A.x-B.x,A.y-B.y);&#125;Vector operator + (Vector A,Vector B)&#123; return Vector(A.x+B.x,A.y+B.y);&#125;bool operator ==(const Point&amp; a,const Point&amp; b)&#123; return (a.x-b.x)==0&amp;&amp;(a.y-b.y)==0;&#125;double cross(Vector a,Vector b)&#123; return a.x*b.y-a.y*b.x;&#125;double Area(Point A,Point B,Point C)&#123; return fabs(cross(B-A,C-A));&#125;bool check(int i,int j,int k)&#123; double area1=Area(a[i],a[j],a[k]); for(int ii=1;ii&lt;=n;ii++)&#123; if(ii!=i&amp;&amp;ii!=j&amp;&amp;ii!=k)&#123; double sum0=Area(a[ii],a[i],a[j])+Area(a[ii],a[i],a[k])+Area(a[ii],a[j],a[k]); double sum1=Area(a[i],a[j],a[k]); if(sum0==sum1) return 0; &#125; &#125; return 1;&#125;int main()&#123; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; char c; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;c; scanf("%lf%lf",&amp;a[i].x,&amp;a[i].y); &#125; double ans=0; int ans1,ans2,ans3; for(int i=1;i&lt;=n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; for(int k=j+1;k&lt;=n;k++)&#123; double area1=Area(a[i],a[j],a[k]); if(check(i,j,k))&#123; double area1=Area(a[i],a[j],a[k]); if(ans&lt;=fabs(area1))&#123; ans=area1; ans1=i,ans2=j,ans3=k; &#125; &#125; &#125; &#125; &#125; printf("%c%c%c\n",ans1-1+'A',ans2-1+'A',ans3-1+'A'); &#125;&#125; POJ3304 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;int n;struct Point &#123; double x,y; Point(double x=0,double y=0):x(x),y(y)&#123;&#125;&#125;s[100],e[100];typedef Point Vector;Vector operator - (Point A,Point B)&#123; return Vector(A.x-B.x,A.y-B.y);&#125;Vector operator + (Vector A,Vector B)&#123; return Vector(A.x+B.x,A.y+B.y);&#125;bool operator ==(const Point&amp; a,const Point&amp; b)&#123; return (a.x-b.x)==0&amp;&amp;(a.y-b.y)==0;&#125;double Cross(Vector a,Vector b)&#123; return a.x*b.y-a.y*b.x;&#125;double Dot(Vector A,Vector B)&#123; return A.x*B.x+A.y+B.y;&#125;const double eps=1e-10;int sgn(double x)&#123; if(fabs(x) &lt; eps)return 0; if(x &lt; 0) return -1; return 1;&#125;int Seg_inter_line(Point a1,Point a2,Point b1,Point b2)&#123; return Cross(a1-b1,a2-b1)*Cross(a1-b2,a2-b2)&lt;=0;&#125;bool check(Point ss,Point ee)&#123; if(Dot(ss-ee,ss-ee) == 0 )return false; for(int i = 1;i &lt;= n;i++)&#123; if(Seg_inter_line(ss,ee,s[i],e[i]) == false) return false; &#125; return true;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%lf%lf%lf%lf",&amp;s[i].x,&amp;s[i].y,&amp;e[i].x,&amp;e[i].y); &#125; int flag=0; for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=n;j++) if(check(s[i],e[i])||check(s[i],s[j])||check(s[i],e[j])||check(e[i],e[j])||check(e[i],s[j])||check(s[j],e[j]))&#123; flag=1; break; &#125; if(flag||n==1) printf("Yes!\n"); else printf("No!\n"); &#125; //system("pause");&#125; POJ1113 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;const int maxn=1e3+10;const double pi=acos(-1.0);struct Point &#123; double x,y; Point (double x=0,double y=0):x(x),y(y)&#123;&#125; bool operator &lt;(const Point &amp;A)&#123; return x==A.x?y&lt;A.y:x&lt;A.x; &#125; bool operator ==(const Point &amp;A)&#123; return x==A.y&amp;&amp;y==A.y; &#125; Point operator -(const Point &amp;A)&#123; return Point(x-A.x,y-A.y); &#125;&#125;a[maxn],ch[maxn];typedef Point Vector;int Cross(Point A,Point B)&#123; return A.x*B.y-A.y*B.x;&#125;int ConvexHull(Point *p,int n,Point *ch)&#123; int m=0; for(int i=0;i&lt;n;i++)&#123; while(m&gt;1&amp;&amp;Cross(ch[m-1]-ch[m-2],a[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; int k=m; for(int i=n-2;i&gt;=0;i--)&#123; while(m&gt;k&amp;&amp;Cross(ch[m-1]-ch[m-2],a[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; if(n&gt;1) m--; return m;&#125;double Dot(Vector A,Vector B)&#123; return A.x*B.x+A.y*B.y;&#125;double Length(Vector A)&#123; return sqrt(Dot(A,A));&#125;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%lf%lf",&amp;a[i].x,&amp;a[i].y); &#125; sort(a,a+n); int len=ConvexHull(a,n,ch); double ans=0; for(int i=1;i&lt;=len;i++)&#123; ans+=Length(ch[i]-ch[i-1]); &#125; ans+=2*pi*m; printf("%.0lf\n",ans); //system("pause");&#125;]]></content>
      <categories>
        <category>几何</category>
      </categories>
      <tags>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[exgcd]]></title>
    <url>%2F2019%2F07%2F02%2Fexgcd%2F</url>
    <content type="text"><![CDATA[POJ2142The Balance 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b==0) &#123;x=1;y=0;return a;&#125; int c=exgcd(b,a%b,x,y); int z=x;x=y;y=z-y*(a/b); return c;&#125;int main()&#123; int a,b,c; // printf("%d\n",__gcd(700,300)); while(~scanf("%d%d%d",&amp;a,&amp;b,&amp;c))&#123; if(a==b&amp;&amp;b==c&amp;&amp;a==0) break; int x,y; int gcd=exgcd(a,b,x,y); // printf("x=%d y=%d\n",x,y); int mod=b/gcd; int t=c/gcd; int x1=(t*x%mod+mod)%mod; int y1=(c-a*x1)/b; int ans1=abs(x1)+abs(y1); // printf("mod=%d x1=%d y1=%d\n",mod,x1,y1); mod=a/gcd; int y2=(t*y%mod+mod)%mod; int x2=(c-y2*b)/a; int ans2=abs(x2)+abs(y2); // printf("mod=%d x2=%d y2=%d\n",mod,x2,y2); if(ans1&gt;ans2)&#123; printf("%d %d\n",abs(x2),abs(y2)); &#125; else printf("%d %d\n",abs(x1),abs(y1)); &#125;&#125; POJ2115C Looooops 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;//#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(b==0) &#123;x=1,y=0;return a;&#125; ll d=exgcd(b,a%b,x,y); ll z=x;x=y;y=z-y*(a/b); return d;&#125;int main()&#123; ll a,b,c,k; while(~scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;k))&#123; if(!a&amp;&amp;!b&amp;&amp;!c&amp;&amp;!k) break; ll x,y; ll l=1; l&lt;&lt;=k; ll gcd=exgcd(c,l,x,y); // printf("gcd=%lld\n",gcd); if((b-a)%gcd==0)&#123; ll t=(b-a)/gcd; l/=gcd; printf("%lld\n",(t*x%l+l)%l); &#125; else printf("FOREVER\n"); &#125; //system("pause");&#125;]]></content>
      <categories>
        <category>数论</category>
        <category>exgcd</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>exgcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断一颗树是否有环]]></title>
    <url>%2F2019%2F06%2F19%2F%E5%88%A4%E6%96%AD%E4%B8%80%E9%A2%97%E6%A0%91%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[判断一个树是否有环123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;int flag=1;int v[100];int head[100],ver[100&lt;&lt;1],nex[100&lt;&lt;1];int tot;void add(int x,int y)&#123; ver[++tot]=y,nex[tot]=head[x],head[x]=tot;&#125;bool dfs(int now,int fa)&#123; // printf("now=%d\n",now); v[now]=1; for(int i=head[now];i;i=nex[i])&#123; int y=ver[i]; // printf("y=%d\n",y); // printf("%d %d\n",now,y); if(y==fa) continue; else &#123; // printf("%d %d\n",now,y); if(v[y]) return 1; if(dfs(y,now)) return 1; &#125; &#125; return 0;&#125;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; add(x,y); add(y,x); &#125; if(dfs(1,0)) printf("you\n"); else printf("wu\n"); for(int i=1;i&lt;=n;i++) printf("%d",v[i]); //system("pause");&#125;]]></content>
      <categories>
        <category>倍增</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倍增题]]></title>
    <url>%2F2019%2F06%2F16%2F%E5%80%8D%E5%A2%9E%2F</url>
    <content type="text"><![CDATA[牛客 区间的连续段题意​ 给你一个长为n的序列a和一个常数k ，有m次询问，每次查询一个区间[l,r]内所有数最少分成多少个连续段，使得每段的和都 &lt;= k ，如果这一次查询无解，输出”Chtholly”。 思路​ 求前缀和，然后先预处理出走一步所能到达得最远的位置，然后用dp[i][j]表示从i点出发分成1&lt;&lt;j段的最远所到达的位置 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;long long a[maxn];int dp[maxn][37];int main()&#123; int n,k,m; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;a[i]); a[i]+=a[i-1]; &#125; a[n+1]=a[n]+k; for(int i=1;i&lt;=n;i++)&#123; int p=lower_bound(a+1,a+n+1,a[i-1]+k+1)-a; dp[i][0]=p; &#125; for(int i=0;i&lt;=31;i++) dp[n+1][i]=n+1; for(int j=1;j&lt;=31;j++)&#123; for(int i=1;i&lt;=n;i++)&#123; dp[i][j]=dp[dp[i][j-1]][j-1]; &#125; &#125; while(m--)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); int ans=0; for(int i=31;i&gt;=0;i--)&#123; if(dp[l][i]&lt;=r)&#123; l=dp[l][i]; ans+=(1&lt;&lt;i); &#125; &#125; if(dp[l][0]&lt;=r) printf("Chtholly\n"); else printf("%d\n",ans+1); &#125; //system("pause");&#125; Educational Codeforces Round 66 (Rated for Div. 2)题意​ 求覆盖目标区域至少需要多少个区间 思路​ dp[i][j]表示从i点出发需要最少需要1&lt;&lt;j的区间覆盖。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e5+10;int a[maxn];int dp[maxn][33];int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); dp[l][0]=max(dp[l][0],r); &#125; for(int i=1;i&lt;maxn;i++) dp[i][0]=max(&#123;dp[i-1][0],dp[i][0]&#125;); for(int j=1;j&lt;=31;j++)&#123; for(int i=0;i&lt;maxn;i++)&#123; dp[i][j]=dp[dp[i][j-1]][j-1]; &#125; &#125; for(int i=0;i&lt;5;i++)&#123; for(int j=0;j&lt;5;j++)&#123; printf("%d ",dp[i][j]); &#125; puts(""); &#125; while(m--)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); int ans=0; if(dp[l][31]&lt;r)&#123; printf("-1\n"); continue; &#125; for(int i=31;i&gt;=0;i--)&#123; if(dp[l][i]&lt;r)&#123; ans+=(1&lt;&lt;i); l=dp[l][i]; &#125; &#125; printf("%d\n",ans+1); &#125; //system("pause");&#125;]]></content>
      <categories>
        <category>倍增</category>
      </categories>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler Problem 51]]></title>
    <url>%2F2019%2F06%2F09%2Feuler%2F</url>
    <content type="text"><![CDATA[Project Euler Problem 51 Prime digit replacements题意​ 将两位数*3的第一个数字代换为任意数字，在九个可能值中有六个是素数：13、23、43、53、73和83。 ​ 将五位数56**3的第三和第四位数字代换为相同的任意数字，就得到了十个可能值中有七个是素数的最小例子，这个素数族是：56003、56113、56333、56443、56663、56773和56993。56003作为这一族中最小的成员，也是最小的满足这个性质的素数。 ​ 通过将部分数字（不一定相邻）代换为相同的任意数字，有时能够得到八个素数，求满足这一性质的最小素数。 答案是*2*3*3 思路​ (1)先打个素数表 ​ (2)对每个素数进行位数计算(计算有几位)，然后枚举换哪一位（我用二进制下进行枚举，个位不能进行枚举，枚举个位的话有一般都是偶数，所有从十位开始枚举） ​ (3)用set存数最后计算set的大小是否等于8，输出结果。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int v[maxn];void prime(int n)&#123; memset(v,0,sizeof v); for(int i=2;i&lt;=n;i++)&#123; if(v[i]) continue; for(int j=i;j&lt;=n/i;j++) v[i*j]=1; &#125;&#125;bool check(int n)&#123; int a[10]; int x=n; int id=0; while(x&gt;0)&#123; a[++id]=x%10; x/=10; &#125; for(int i=1;i&lt;(1&lt;&lt;(id-1));i++)&#123; set&lt;int&gt; s; for(int j=0;j&lt;=9;j++)&#123; int b[10]; for(int k=1;k&lt;=id;k++) b[k]=a[k]; for(int k=0;k&lt;=4;k++) if(i&amp;(1&lt;&lt;k)) b[k+2]=j; int ans=0; for(int k=id;k&gt;=1;k--) ans=ans*10+b[k]; if(!v[ans]) s.insert(ans); &#125; if(*s.begin()==n&amp;&amp;s.size()==8) return 1; &#125; return 0;&#125;int main()&#123; prime(maxn); for(int i=101;i&lt;1000000;i+=2)&#123; if(!v[i]&amp;&amp;check(i))&#123; printf("%d\n",i); break; &#125; &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>Project Euler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TSP小测]]></title>
    <url>%2F2019%2F05%2F24%2FTSP%E5%B0%8F%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[POJ5067题意​ 有一个n*m的矩阵上存在一些石头，接下来要从起点出发把这些石头拿上并回到起点，问最小需要多少步。 思路​ 用sum表示除了(1,1)这个点外其他有石头的点的个数，用x数组和y数组表示这些点的坐标的位置，在这里我用二进制下的每个位置表示点的位置，将最后的位置来表示起点，0 - n-1分别表示其他点的位置，然后开始暴力枚举二进制下的每个数字，注意初始化dp[0] [n]=0. 代码 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int x[20],y[20];int ma[60][60];int dp[1&lt;&lt;12][15];int dis(int i,int j)&#123; return abs(x[i]-x[j])+abs(y[i]-y[j]);&#125;int main()&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; int sum=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; scanf("%d",&amp;ma[i][j]); if(i==1&amp;&amp;j==1) continue; if(ma[i][j])&#123; x[sum]=i; y[sum]=j; sum++; &#125; &#125; x[sum]=1,y[sum]=1; n=sum; memset(dp,0x3f,sizeof(dp)); dp[0][n]=0; for(int st=0;st&lt;(1&lt;&lt;n);st++)&#123; for(int i=0;i&lt;=n;i++)&#123; dp[st][n]=min(dp[st][n],dp[st][i]+dis(i,n)); for(int j=0;j&lt;n;j++)&#123; dp[st|1&lt;&lt;j][j]=min(dp[st|1&lt;&lt;j][j],dp[st][i]+dis(i,j)); &#125; &#125; &#125; printf("%d\n",dp[(1&lt;&lt;n)-1][n]); &#125;&#125; HDU3311题意​ 给n个地点，然后输入一个(n+1)*(n+1)的矩阵，第i行第j列表示第i个地点到第j个地点的时间，要从第0个地点用最短的时间走遍1-n个地点，并回到原点。 思路​ 先用Floyd最短路径算法求出任意俩点之间的最短时间，接下来就是一个TSP板子，记住最后再让他回到原点就行了。 代码123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std ;int d[20][20];int dp[1&lt;&lt;12][20];int main()&#123; int n; while(~scanf("%d",&amp;n))&#123; if(n==0) break; for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=n;j++)&#123; scanf("%d",&amp;d[i][j]); &#125; &#125; for(int k=0;k&lt;=n;k++) for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]); memset(dp,0x3f,sizeof(dp)); dp[1][0]=0; n++; for(int i=1;i&lt;1&lt;&lt;n;i++) for(int j=0;j&lt;n;j++) if(i&gt;&gt;j&amp;1) for(int k=0;k&lt;n;k++) if((i^1&lt;&lt;j)&gt;&gt;k&amp;1) dp[i][j]=min(dp[i][j],dp[i^1&lt;&lt;j][k]+d[k][j]); int ans=0x3f3f3f3f; for(int i=1;i&lt;n;i++) ans=min(ans,dp[(1&lt;&lt;n)-1][i]+d[i][0]); printf("%d\n",ans); &#125;&#125; HDU4856题意​ 有一个n*n的地图，.表示可行走的路，#表示障碍，接下来有m行，x1,y2,x2,y2分别表示隧道的入口和出口，最后求走完这些隧道并且只能走一次需要多长时间。 思路​ 首先bfs所有隧道从入口到另一个隧道出口的时间，如果不能到达将它置为-1，然后就是初始化从每个起点出发（也就是for(int i=0;i&lt;m;i++) dp[1&lt;&lt;i] [i]=0;）剩下的就越是单纯的TSP模板了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int INF = 0x3f3f3f3f;struct point&#123; int x1,y1,x2,y2;&#125;p[17];int n,m;char ma[17][17];int mp[17][17],visit[17][17],dp[1&lt;&lt;15][17];int step[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;bool check(int x,int y)&#123; return x&lt;=n&amp;&amp;x&gt;=1&amp;&amp;y&lt;=n&amp;&amp;y&gt;=1&amp;&amp;ma[x][y]!='#';&#125; int bfs(point x,point y)&#123; queue&lt;pair&lt;int,int&gt; &gt; q; memset(visit,-1,sizeof(visit)); q.push(make_pair(x.x2,x.y2)); visit[x.x2][x.y2]=0; while(q.size())&#123; pair&lt;int,int&gt; now=q.front(); q.pop(); if(now.first==y.x1&amp;&amp;now.second==y.y1) return visit[y.x1][y.y1]; for(int i=0;i&lt;=3;i++)&#123; int tx=now.first+step[i][0],ty=now.second+step[i][1]; if(check(tx,ty)&amp;&amp;visit[tx][ty]==-1) &#123; visit[tx][ty]=visit[now.first][now.second]+1; q.push(make_pair(tx,ty)); &#125; &#125; &#125; return -1;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; for(int i=1;i&lt;=n;i++) scanf("%s",ma[i]+1); for(int i=0;i&lt;m;i++)&#123; scanf("%d%d%d%d",&amp;p[i].x1,&amp;p[i].y1,&amp;p[i].x2,&amp;p[i].y2); &#125; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(i==j) mp[i][j]=0; else mp[i][j]=bfs(p[i],p[j]); &#125; &#125; for(int i=1;i&lt;1&lt;&lt;m;i++)&#123; for(int j=0;j&lt;m;j++)&#123; dp[i][j]=0x3f3f3f3f; &#125; &#125; for(int i=0;i&lt;m;i++) dp[1&lt;&lt;i][i]=0; for(int i=0;i&lt;1&lt;&lt;m;i++)&#123; for(int j=0;j&lt;m;j++) if(i&gt;&gt;j&amp;1) for(int k=0;k&lt;m;k++) if(((i^1&lt;&lt;j)&gt;&gt;k&amp;1)&amp;&amp;mp[k][j]!=-1) dp[i][j]=min(dp[i][j],dp[i^1&lt;&lt;j][k]+mp[k][j]); &#125; int ans=0x3f3f3f3f; for(int i=0;i&lt;m;i++) ans=min(ans,dp[(1&lt;&lt;m)-1][i]); if(ans==0x3f3f3f3f) printf("-1\n"); else printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>状态压缩DP</category>
      </categories>
      <tags>
        <tag>状态压缩DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论小测]]></title>
    <url>%2F2019%2F05%2F09%2F%E6%95%B0%E8%AE%BA%E5%B0%8F%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[hdu5207Greatest Greatest Common Divisor题意​ 给定n个数求任意俩个数得最大公因数 思路​ 因为之前写过求俩个数得最小公倍数，所以这道问题迎刃而解，就是枚举他们得因数，用数组记录每个因数出现的次数，最后从大到小找出现俩次得那个数，输出即可。 代码1123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;int a[maxn];int main()&#123; int t; cin&gt;&gt;t; int id=0; while(t--)&#123; memset(a,0,sizeof a); int n; scanf("%d",&amp;n); int maxx=-1; for(int i=1;i&lt;=n;i++)&#123; int x; scanf("%d",&amp;x); maxx=max(x,maxx); for(int i=1;i*i&lt;=x;i++)&#123; if(!(x%i))&#123; a[i]++; if(x/i!=i)&#123; a[x/i]++; &#125; &#125; &#125; &#125; int ans=0; for(int i=maxx;i&gt;=1;i--)&#123; if(a[i]&gt;=2) &#123; ans=i; break; &#125; &#125; printf("Case #%d: %d\n",++id,ans); &#125;&#125; 但后来听大佬的正解，发现是先预处理出所有数的因数直接在循环中累计个数就🆗了。 代码212345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;vector&lt;int&gt; c[maxn];int v[maxn];void init()&#123; for(int i=1;i&lt;maxn;i++)&#123; for(int j=i;j&lt;maxn;j+=i)&#123; c[j].push_back(i); &#125; &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; init(); int id=0; while(t--)&#123; memset(v,0,sizeof v); int n; cin&gt;&gt;n; int maxx=-1; for(int i=1;i&lt;=n;i++)&#123; int x; cin&gt;&gt;x; maxx=max(maxx,x); for(int j=0;j&lt;c[x].size();j++)&#123; v[c[x][j]]++; &#125; &#125; int x=0; for(int i=maxx;i&gt;=1;i--)&#123; if(v[i]&gt;=2)&#123; x=i; break; &#125; &#125; printf("Case #%d: %d\n",++id,x); &#125; //system("pause"); return 0;&#125; HDU5698瞬间移动题意​ 无限大的矩形，从(1,1)每次可以瞬移到右下方格的任意一个格子，求最后到达(n,m)的方案数。 思路​ 枚举中间走的步数i，中间走的最大步数必然是min(m-2,n-2)步，然后开始枚举。 代码112345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int mod=1e9+7;const int maxn=1e6+10;int jc[maxn],jcinv[maxn];int C(int n,int m)&#123; return 1ll*jc[n]*jcinv[m]%mod*jcinv[n-m]%mod;&#125;int ksm(int a,int b)&#123; int c=1; for(;b;b&gt;&gt;=1)&#123; if(b&amp;1) c=1ll*c*a%mod; a=1ll*a*a%mod; &#125; return c;&#125;int main()&#123; jc[0]=1,jcinv[0]=1; jc[1]=1,jcinv[1]=1; for(int i=2;i&lt;=maxn;i++)&#123; jc[i]=1ll*jc[i-1]*i%mod; jcinv[i]=ksm(jc[i],mod-2); &#125; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; int ans=0; for(int i=0;i&lt;=min(n-2,m-2);i++)&#123; ans=(ans+1ll*C(n-2,i)*C(m-2,i)%mod)%mod; &#125; printf("%d\n",ans); &#125; return 0;&#125; 网上查阅的答案为C(n+m-4,n-2) 代码21234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int mod=1e9+7;const int maxn=1e6+10;int jc[maxn],jcinv[maxn];int C(int n,int m)&#123; return 1ll*jc[n]*jcinv[m]%mod*jcinv[n-m]%mod;&#125;int ksm(int a,int b)&#123; int c=1; for(;b;b&gt;&gt;=1)&#123; if(b&amp;1) c=1ll*c*a%mod; a=1ll*a*a%mod; &#125; return c;&#125;int main()&#123; jc[0]=1,jcinv[0]=1; jc[1]=1,jcinv[1]=1; for(int i=2;i&lt;=maxn;i++)&#123; jc[i]=1ll*jc[i-1]*i%mod; jcinv[i]=ksm(jc[i],mod-2); &#125; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; printf("%d\n",C(n+m-4,n-2)); &#125; return 0;&#125; cfdiv2 Modified GCD题意​ 给定俩个数a和b，然后给m个查询，每行俩个整数x和y，表示查询x到y之间最大a和b的因数。 思路​ 这也太简单了，直接预处理出gcd(a,b)的所有因数，排序，二分查找第一个比b大的数的下标位置，在把这个位置向后倒退一步，再判断是否为x-y这个区间内，是则输出，否则输出-1. 代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int c[maxn];int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; int x=__gcd(a,b); int id=0; for(int i=1;i*i&lt;=x;i++)&#123; if(x%i==0)&#123; c[++id]=i; if(x/i!=i) c[++id]=x/i; &#125; &#125; sort(c+1,c+id+1); // for(int i=1;i&lt;=id;i++) cout&lt;&lt;c[i]&lt;&lt;endl; int m; cin&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;a&gt;&gt;b; x=upper_bound(c+1,c+id+1,b)-c; x--; if(c[x]&lt;=b&amp;&amp;c[x]&gt;=a) cout&lt;&lt;c[x]&lt;&lt;endl; else cout&lt;&lt;-1&lt;&lt;endl; &#125; //system("pause"); return 0;&#125; BZOJ2818 Gcd题意​ 给定整数N，求1&lt;=x,y&lt;=N且Gcd(x,y)为素数的数对(x,y)有多少对. 思路​ 由题意得： ​ gcd(x,y)=p ​ gcd(x/p,y/p)=1 ​ 所以枚举每个素数(代码中m表示n以内的素数个数)，求n/p以内俩俩互质对数的个数，最后再乘p即为所求的gcd(x,y)=p ,因为俩个数顺序变换也算，所以最后乘2，另外(1,1)是个特殊的存在所以在计算的时候减去最后再加即可。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=1e7+10;int v[maxn],prime[maxn],phi[maxn];long long sum[maxn];int m;void euler(int n)&#123; memset(v,0,sizeof(v)); m=0; phi[1]=1; for(int i=2;i&lt;=n;i++)&#123; if(v[i]==0)&#123; v[i]=i; prime[++m]=i; phi[i]=i-1; &#125; for(int j=1;j&lt;=m;j++)&#123; if(prime[j]&gt;v[i]||prime[j]&gt;n/i) break; v[i*prime[j]]=prime[j]; phi[i*prime[j]]=phi[i]*(i%prime[j]?prime[j]-1:prime[j]); &#125; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; euler(n); for(int i=1;i&lt;=n;i++) sum[i]=phi[i]+sum[i-1]; long long ans=0; for(int i=1;i&lt;=m;i++) ans+=(sum[n/prime[i]]-1); printf("%lld\n",2*ans+m); //system("pause");&#125; POJ1061青蛙的约会题意​ 有俩个青蛙A和B，在一个长为l的环形上，初始时A在x处每次跳m米，B在y处每次跳n米，求最后需要跳几次才能相遇。 思路​ 很明显一个扩展欧几里得的模板题。 ​ 因为(x+mt)%l=(y+nt)%l, ​ 移项得(m-n)t%l=(y-x)%l ​ 得(m-n)t+lk=(y-x) ​ 对应扩展欧几里得中(ax+by=c) ， (m-n)为a，l为b ，c为(y-x). ​ 最后求得得数为x得解，因为可能为负数所以最后((x*c/gcd(a,b)%l)+l)%l。 代码1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(b==0) &#123;x=1,y=0;return a;&#125; ll d=exgcd(b,a%b,x,y); ll z=x;x=y;y=z-y*(a/b); return d;&#125;int main()&#123; ll n,m,x,y,l; while(~scanf("%lld%lld%lld%lld%lld",&amp;x,&amp;y,&amp;m,&amp;n,&amp;l))&#123; ll t,k; ll gcd=exgcd(m-n,l,t,k); ll c=(y-x)/gcd; if((y-x)%gcd) puts("Impossible"); else printf("%lld\n",((t*c)%l+l)%l); &#125;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU5242]]></title>
    <url>%2F2019%2F05%2F08%2FHDU524%2F</url>
    <content type="text"><![CDATA[HDU5242 题意​ 一棵树有n个结点，n-1条边，每个结点有个权值。每次可以获得从根节点走到叶子结点所有结点的权值和，但是每个结点的权值只能使用一次。求走k次所能获得的最大权值和。 思路​ 先进行第一次dfs，求出每条从根到叶子节点的链，然后将这些链排序，在进行第二遍dfs,求出抛去重复走的路径，在一次对所求的结果进行排序，取前m大加起来就行。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;typedef long long ll;int n,m;int head[maxn],ver[maxn],nex[maxn];int tot,p;int w[maxn];int visit[maxn],fa[maxn];ll ans[maxn];struct point&#123; ll x,y;&#125;a[maxn];bool cmp(point a,point b)&#123; return a.y&gt;b.y;&#125;void add(int u,int v)&#123; ver[++tot]=v,nex[tot]=head[u],head[u]=tot;&#125;void init()&#123; memset(head,0,sizeof head); memset(visit,0,sizeof visit); tot=0; p=0;&#125;void dfs(ll now,ll val)&#123; if(head[now])&#123; for(int i=head[now];i;i=nex[i])&#123; int y=ver[i]; dfs(y,val+w[now]); &#125; &#125; else &#123; a[++p].x=now,a[p].y=val+w[now]; &#125;&#125;ll dfs1(ll now)&#123; if(visit[now]) return 0; visit[now]=1; return dfs1(fa[now])+w[now];&#125;int main()&#123; int t; cin&gt;&gt;t; int id=0; while(t--)&#123; init(); scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); for(int i=1;i&lt;=n-1;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v); fa[v]=u; &#125; dfs(1,0); sort(a+1,a+p+1,cmp); for(int i=1;i&lt;=n;i++)&#123; ans[i]=dfs1(a[i].x); &#125; sort(ans+1,ans+p+1,greater&lt;ll&gt;()); ll res=0; for(int i=1;i&lt;=m;i++)&#123; res+=ans[i]; &#125; printf("Case #%d: %lld\n",++id,res); &#125; //system("pause");&#125;]]></content>
      <categories>
        <category>贪心</category>
        <category>dfs</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ4092]]></title>
    <url>%2F2019%2F05%2F08%2FZOJ4092%2F</url>
    <content type="text"><![CDATA[ZOJ4092 题意​ 求最后所给式子的和。 思路​ 因为2的30次方大于1e9，所以分母范围只可能是1-30，枚举分母预处理所有情况的前缀和，最后二分查找答案。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=5e5+10; const int mod=1e9;ll a[maxn],p[maxn];ll sum[maxn][31];int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=30;j++)&#123; sum[i][j]=sum[i-1][j]+a[i]/j; &#125; &#125; ll res=0; for(int i=1;i&lt;=m;i++)&#123; scanf("%d",&amp;p[i]); ll pp=p[i]; ll ans=0; //printf("i=%d\n",i); int l=1,r=1; for(int pos=1;pos&lt;=30;pp*=p[i],pos++)&#123; r=upper_bound(a+1,a+n+1,pp)-a; //printf("l=%d r=%d\n",l,r); ans=(ans+sum[r-1][pos]-sum[l-1][pos])%mod; l=r; if(pp&gt;a[n]) break; &#125; //printf("ans=%lld\n",ans); res=(res+i*ans%mod)%mod; &#125; printf("%lld\n",res); &#125; //system("pause");&#125;]]></content>
      <categories>
        <category>二分</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F24%2F%E4%BB%A3%E7%A0%81%EF%BC%9A%2F</url>
    <content type="text"><![CDATA[代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 500000+10;const LL inf = 1e17;int n;int i,j;LL sum[maxn],stmx[maxn][23],stmn[maxn][23];int a[maxn],l[maxn],r[maxn];stack&lt;int&gt; sta;LL askmx(int l,int r)&#123; int k=log2(r-l+1); return max(stmx[l][k],stmx[r-(1&lt;&lt;k)+1][k]);&#125;LL askmn(int l,int r)&#123; int k=log2(r-l+1); return min(stmn[l][k],stmn[r-(1&lt;&lt;k)+1][k]);&#125;int main()&#123; scanf("%d",&amp;n); for (i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for (i=1;i&lt;=n;i++) sum[i]=sum[i-1]+(LL)a[i]; for (i=0;i&lt;=n;i++) stmx[i][0]=stmn[i][0]=sum[i]; for (j=1;(1&lt;&lt;j)&lt;=n+1;j++)&#123; for (i=0;i+(1&lt;&lt;j)-1&lt;=n;i++)&#123; stmx[i][j]=max(stmx[i][j-1],stmx[i+(1&lt;&lt;(j-1))][j-1]); stmn[i][j]=min(stmn[i][j-1],stmn[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125; for (i=1;i&lt;=n;i++)&#123; while (!sta.empty()&amp;&amp;a[i]&lt;=a[sta.top()]) sta.pop(); if (sta.empty()) l[i]=1; else l[i]=sta.top()+1; sta.push(i); &#125; while (!sta.empty()) sta.pop(); for (i=n;i&gt;=1;i--)&#123; while (!sta.empty()&amp;&amp;a[i]&lt;=a[sta.top()]) sta.pop(); if (sta.empty()) r[i]=n; else r[i]=sta.top()-1; sta.push(i); &#125; LL ans=-inf; for (i=1;i&lt;=n;i++)&#123; if (a[i]&lt;0)&#123; LL R=askmn(i,r[i]); LL L=askmx(l[i]-1,i-1); ans=max(ans,(R-L)*(LL)a[i]); &#125; else if (a[i]&gt;0)&#123; LL R=askmx(i,r[i]); LL L=askmn(l[i]-1,i-1); ans=max(ans,(R-L)*(LL)a[i]); &#125; else&#123; ans=max(ans,0ll); &#125; &#125; printf("%lld\n",ans); system("pause"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法作业一]]></title>
    <url>%2F2019%2F04%2F24%2F%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[归并排序1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;const int maxn=1e5+10;int tmp[maxn];int a[maxn];void merge( int start, int mid, int end)&#123; int i = start; int j = mid + 1; int k = 0; while(i &lt;= mid &amp;&amp; j &lt;= end)&#123; if (a[i] &lt;= a[j]) tmp[k++] = a[i++]; else tmp[k++] = a[j++]; &#125; while(i &lt;= mid) tmp[k++] = a[i++]; while(j &lt;= end) tmp[k++] = a[j++]; for (i = 0; i &lt; k; i++) a[start + i] = tmp[i];&#125;void mergeSort( int start, int end)&#123; if(start &gt;= end) return ; int mid = (end + start)/2; mergeSort( start, mid); mergeSort( mid+1, end); merge(start, mid, end);&#125;int main()&#123; int n; cin&gt;&gt;n; for (int i=1; i&lt;=n; i++) cin&gt;&gt;a[i]; mergeSort(1, n); for (int i=1; i&lt;=n; i++) cout &lt;&lt; a[i] &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; 棋盘覆盖123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e4+10;int m[maxn][maxn];int n=0;void chessboard(int x,int y,int tx,int ty,int s)&#123; if(s==1) return; s&gt;&gt;=1; int t=++n; if(tx&lt;=x+s-1&amp;&amp;ty&lt;=y+s-1) chessboard(x,y,tx,ty,s); else m[x+s-1][y+s-1]=t,chessboard(x,y,x+s-1,y+s-1,s); if(tx&lt;=x+s-1&amp;&amp;ty&gt;=y+s) chessboard(x,y+s,tx,ty,s); else m[x+s-1][y+s]=t,chessboard(x,y+s,x+s-1,y+s,s); if(tx&gt;=x+s&amp;&amp;ty&lt;=y+s-1) chessboard(x+s,y,tx,ty,s); else m[x+s][y+s-1]=t,chessboard(x+s,y,x+s,y+s-1,s); if(tx&gt;=x+s&amp;&amp;ty&gt;=y+s) chessboard(x+s,y+s,tx,ty,s); else m[x+s][y+s]=t,chessboard(x+s,y+s,x+s,y+s,s);&#125;int main()&#123; while(true)&#123; int size; cin&gt;&gt;size; int x,y; cin&gt;&gt;x&gt;&gt;y; chessboard(1,1,x,y,size); for(int i=1;i&lt;=size;i++)&#123; for(int j=1;j&lt;=size;j++)&#123; printf("%3d ",m[i][j]); &#125; printf("\n"); &#125; &#125;&#125; 循环日程表12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int n,half=1,k=1;int pic[100][100];int main()&#123; cin&gt;&gt;n; pic[0][0]=1; int m=1&lt;&lt;n; while(k&lt;=n)&#123; for(int i=0;i&lt;half;i++)&#123; for(int j=0;j&lt;half;j++)&#123; pic[i][j+half]=pic[i][j]+half; &#125; &#125; for(int i=0;i&lt;half;i++)&#123; for(int j=0;j&lt;half;j++)&#123; pic[i+half][j]=pic[i][j+half]; pic[i+half][j+half]=pic[i][j]; &#125; &#125; half*=2; k++; &#125; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;m;j++)&#123; printf("%3d",pic[i][j]); &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 快速排序1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;int a[maxn];void quicksort(int left,int right)&#123; if(left&gt;right) return ; int temp=a[left]; int i=left; int j=right; while(i!=j)&#123; while(a[j]&gt;=temp&amp;&amp;i&lt;j) j--; while(a[i]&lt;=temp&amp;&amp;i&lt;j) i++; if(i&lt;j)&#123; int t=a[i]; a[i]=a[j]; a[j]=t; &#125; &#125; a[left]=a[i]; a[i]=temp; quicksort(left,i-1); quicksort(i+1,right);&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; quicksort(1,n); for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;" "; puts(""); return 0;&#125;]]></content>
      <categories>
        <category>二分</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ST算法]]></title>
    <url>%2F2019%2F04%2F22%2FST%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[介绍RMQ (Range Minimum/Maximum Query)问题是指：对于长度为n的数列A，回答若干询问RMQ(A,i,j)(i,j&lt;=n)，返回数列A中下标在i,j里的最小(大）值，也就是说，RMQ问题是指求区间最值的问题。 ​ ST算法就是倍增的产物，ST算法能在O(nlogN)的预处理后，以O(1)的时间求出区间最值问题(当然也能求出其他问题)。思想上类似于动态规划，每次从上一次转移(状态转移方程看下面)。 思路​ 数列A是一个二维数组，A[i] [j]表示从第i个数字起长度为2的j次方的最大值。每次都成倍增长，公式 F[i,j]=max(F[i][j-1],F[i+2的(j-1)次方][j-1])长度为2的j次方的最大值是左右俩半长度为2的j-1次方的子区间中较大的一个。 代码预处理函数 123456789void ST()&#123; for(int i=1;i&lt;=n;i++) f[i][0]=a[i]; int t=log(n)/log(2)+1; for(int j=1;j&lt;t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125;&#125; 查询函数 1234int ST_query(int l,int r)&#123; int k=log(r-l+1)/log(2); return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125; 例题P3865 【模板】ST表 代码12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int n,m;int f[maxn][50];int a[maxn];void ST()&#123; for(int i=1;i&lt;=n;i++) f[i][0]=a[i]; int t=log(n)/log(2)+1; for(int j=1;j&lt;t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125;&#125;int ST_query(int l,int r)&#123; int k=log(r-l+1)/log(2); return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; ST(); for(int i=1;i&lt;=m;i++)&#123; int l,r; cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;ST_query(l,r)&lt;&lt;"\n"; &#125; system("pause");&#125;]]></content>
      <categories>
        <category>RMQ</category>
      </categories>
      <tags>
        <tag>RMQ</tag>
        <tag>ST算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长上升子序列LIS]]></title>
    <url>%2F2019%2F04%2F18%2F%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97(LIS)%2F</url>
    <content type="text"><![CDATA[介绍最长上升子序列问题，也就是Longest increasing subsequence，缩写为LIS。是指在一个序列中求长度最长的一个上升子序列的问题，是动态规划中一个相当经典问题。在这里我们可以看到，这个上升实质上就是一个对&lt;进行定义的过程，所以我们求解的其实是一类问题，也就是在给定序列中求解长度最长的符合某一性质的子序列的问题。 解法一状态设计：F[i]代表以A[i]结尾的LIS的长度状态转移：F[i]=max{F[j]+1}(1&lt;=j&lt; i,A[j]&lt; A[i])边界处理：F[i]=1(1&lt;=i&lt;=n)时间复杂度：O(n^2)PS(理解dp最简单的方法：画表，自行推理) 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int a[maxn],dp[maxn];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); dp[i]=1; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;i;j++)&#123; if(a[j]&lt;a[i]) dp[i]=max(dp[i],dp[j]+1); &#125; &#125; int maxx=0; for(int i=1;i&lt;=n;i++) maxx=max(maxx,dp[i]); printf("%d\n",maxx); return 0; &#125; 解法二贪心加二分 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;const int INF=0x7f7f7f7f;int a[maxn],dp[maxn];int binary_search(int l,int r,int x)&#123;//二分查找第一个大于等于x的元素 while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(dp[mid]&lt;=x) l=mid+1; else r=mid-1; &#125; return l;&#125;int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); dp[i]=INF;//初始化为无穷大 &#125; int pos=1; dp[1]=a[1]; for(int i=2;i&lt;=n;i++)&#123; if(a[i]&gt;dp[pos]) dp[++pos]=a[i];// else dp[lower_bound(dp+1,dp+pos+1,a[i])-dp]=a[i];//lower_bound(a,a+n,x)函数 返回从数组a到a+n中第一个&gt;=x的元素地址 else dp[binary_search(1,pos,a[i])]=a[i];//也可以自己写二分查找。 &#125; printf("%d\n",pos); return 0;&#125; 解法三用树状数组维护，降低复杂度。PS(我写完后发现这个方法将相等的也计算在其中)。不知道有没有人能去除掉相等，是我太菜了，QWQ.维护每个数的序列也就是第几个数，然后查询其前面的最长上升子序列，然后更新其后的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int n,dp[maxn];struct point&#123; int x,id; bool operator &lt; (const point &amp;a) const&#123; return x&lt;a.x||(a.x==x&amp;&amp;a.id&gt;id); &#125;&#125;;int lowbit(int x)&#123; return x&amp;(-x);&#125;int query(int x)&#123; int sum=0; while(x)&#123; sum=max(sum,dp[x]); x-=lowbit(x); &#125; return sum;&#125;void modify(int x,int y)&#123; while(x&lt;=n)&#123; dp[x]=max(dp[x],y); x+=lowbit(x); &#125;&#125;point a[maxn];int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i].x); a[i].id=i; &#125;// for(int i=1;i&lt;=n;i++) printf("%d %d\n",a[i].x,a[i].id);// printf("\n"); sort(a+1,a+n+1);// for(int i=1;i&lt;=n;i++) printf("%d %d\n",a[i].x,a[i].id); int ans=0; for(int i=1;i&lt;=n;i++)&#123; int maxx=query(a[i].id); modify(a[i].id,++maxx); ans=max(ans,maxx); &#125; printf("%d\n",ans); return 0;&#125; 解法四随后我查了相关的博客后，发现换个思维就可以排除相等的情况。即维护每一个刚输入的值，查询其前面的最长的上升子序列。 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int n,dp[maxn];int lowbit(int x)&#123; return x&amp;(-x);&#125;int query(int x)&#123; int sum=0; while(x)&#123; sum=max(sum,dp[x]); x-=lowbit(x); &#125; return sum;&#125;void modify(int x,int y)&#123; while(x&lt;=maxn)&#123; dp[x]=max(dp[x],y); x+=lowbit(x); &#125;&#125;int main()&#123; scanf("%d",&amp;n); int ans=0; for(int i=1;i&lt;=n;i++)&#123; int x; scanf("%d",&amp;x); x++;//因为树状数组从1开始，每次查询x-1以及前面的最大值 int maxx=query(x-1)+1; ans=max(ans,maxx); modify(x,maxx); &#125; printf("%d\n",ans);&#125; 不过解法三和四都有一定的局限性，只能所有数都是&gt;=1的正整数时才能用，不过这种思维可以用在好多地方。如果存在负数的情况，用方法二是最好的。]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>LIS</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj1845sumdiv]]></title>
    <url>%2F2019%2F04%2F18%2Fsumdiv%2F</url>
    <content type="text"><![CDATA[poj1845 sumdiv 题意求$A^B$的所有约束之和mod9901. 思路​ A可以写成 p_1^c1*p_2^c2*……*p_n^cn​ 然后 A^B可以写成p_1^c1^B*p_2^c2*B*……*p_n^cn*^B 然后A^B的约数可以写成 (1+p_1+p_1^2+……+p_1^c1^B)*(1+p_2+p_2^2+……+p_2^c2*B)*…… *(1+p_n+p_n^2+……+p_n^cn*^B)而等比数列的公式可以写成 (p_1^b*^c_1+1)/(p_1+1) (p_1-1)不是9901的倍数时可以用逆元求出但当(p_1-1)是9901的倍数时，无法求逆元 这时p_1模除9901时余1这时带入(1+p_i+p_i^2+……+p_i^ci*B)得到B*c_1+1这样问题就得以解决。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;const int mod=9901;int a,b;int p[20],c[20];int m=0;void divide(int x)&#123; for(int i=2;i*i&lt;=x;i++)&#123; if(x%i==0)&#123; p[++m]=i; c[m]=0; while(x%i==0) x/=i,c[m]++; &#125; &#125; if(x&gt;1) p[++m]=x,c[m]=1;&#125;long long ksm(long long a,long long b) &#123; int c = 1; while(b)&#123; if(b&amp;1) c=c*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return c;&#125;int main()&#123; cin&gt;&gt;a&gt;&gt;b; long long ans=1; divide(a); for(int i=1;i&lt;=m;i++)&#123; if((p[i]-1)%mod==0)&#123; ans=(b*c[i]+1)%mod*ans%mod; &#125; else&#123; long long x=(ksm(p[i],b*c[i]+1)-1+mod)%mod; x*=ksm(p[i]-1,mod-2)%mod; ans=ans*x%mod; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[div3G.Teams]]></title>
    <url>%2F2019%2F04%2F18%2FTeams%2F</url>
    <content type="text"><![CDATA[Codeforces Round #552 (Div. 3) G. Two Teams 题意找到俩个数使他俩的LCM最小,输出这俩个数的下标。 思路 每次枚举每个数的因子,然后求lcm,将最小的LCM的俩个下标存起来。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e7+10;int a[maxn];int v[maxn];int main()&#123; int n; cin&gt;&gt;n; int maxx=0; int ans0=0x3f3f3f3f,ans1=0x3f3f3f3f; long long ma=1e16; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; maxx=max(maxx,a[i]); if(v[a[i]])&#123; long long temp=a[i]; if(ma&gt;temp)&#123; ma=temp; ans0=v[a[i]]; ans1=i; &#125; &#125; v[a[i]]=i; &#125; for(int i=1;i&lt;=maxx;i++)&#123; int ans00=-1,ans11=-1; for(int j=i;j&lt;=maxx;j+=i)&#123; if(v[j])&#123; if(ans00==-1) ans00=j; else ans11=j; &#125; if(ans11!=-1&amp;&amp;ans00!=-1) break; &#125; if(ans11!=-1)&#123; long long temp=1ll*ans11*ans00/i; if(ma&gt;temp)&#123; ma=temp; ans0=v[ans00]; ans1=v[ans11]; &#125; &#125; &#125; if(ans0&gt;ans1) swap(ans0,ans1); printf("%d %d\n",ans0,ans1);&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1091合唱队形]]></title>
    <url>%2F2019%2F04%2F16%2FP1091%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[P1091 合唱队形 题意n位同学站成一排,要求满足所选同学的身高严格单调递增在递减，问最少需要几位同学出列 思路 先正的求一遍LIS，在逆着求一边LIS，最后再求以i(1&lt;=i&lt;=n)为一个转折点求最大的和即为所要求的人（这里要减去1不仅要防止不选还要防止选这一位置俩次），最后在用总数减去这个最大的人数即为所求答案。用贪心加二分的LIS求最长连续子序列，复杂度为o(n). 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100+10;int dp[2][maxn];int a[maxn];int b[maxn];int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; b[1]=a[1]; dp[0][1]=1; int pos=1; for(int i=2;i&lt;=n;i++)&#123; if(a[i]&gt;b[pos]) &#123; pos++; dp[0][i]=pos; b[pos]=a[i]; &#125; else &#123; b[lower_bound(b+1,b+pos+1,a[i])-b]=a[i]; dp[0][i]=pos; &#125; &#125; b[1]=a[n]; dp[1][1]=1; pos=1; for(int i=n-1,j=2;i&gt;=1;i--,j++)&#123; if(a[i]&gt;b[pos]) &#123; pos++; dp[1][j]=pos; b[pos]=a[i]; &#125; else &#123; b[lower_bound(b+1,b+pos+1,a[i])-b]=a[i]; dp[1][j]=pos; &#125; &#125; int maxx=0; for(int i=1;i&lt;=n;i++)&#123; maxx=max(maxx,dp[0][i]+dp[1][n-i+1]-1); &#125; printf("%d\n",n-maxx);&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>LIS</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Median String]]></title>
    <url>%2F2019%2F04%2F15%2F%E6%A8%A1%E6%8B%9F%E6%8B%9F-%E4%B8%AD%E7%AD%89%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Codeforces Round #550 (Div. 3)E. Median String 题意：输入一个n表示一个字符串里面有几个字符，然后寻找这俩个字符串中间的字符。 思路：模拟26位进制数表示 代码：123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+10;int ans[maxn];int main()&#123; int n; cin&gt;&gt;n; string a,b; cin&gt;&gt;a&gt;&gt;b; for(int i=n-1;i&gt;=0;i--)&#123; ans[i]=a[i]-'a'+b[i]-'a'; if(ans[i]&amp;1)&#123; ans[i+1]+=13; ans[i]=ans[i]-1&gt;&gt;1; ans[i]+=ans[i+1]/26; ans[i+1]%=26; &#125; else&#123; ans[i]&gt;&gt;=1; &#125; &#125; for(int i=0;i&lt;n;i++) printf("%c",'a'+ans[i]); cout&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu4576 Robot]]></title>
    <url>%2F2019%2F04%2F14%2F%E6%A6%82%E7%8E%87dp%2F</url>
    <content type="text"><![CDATA[题意​ 在一个环形区域里面分成n个部分，初始在第一个部分(顺时针1到n)，截下来有m次操作，每次可以顺势针或者逆时针走a步问最后走在l到r这个区域内的概率是多少？ 思路 ​ 一道标准的概率dp题，每次走路都由上一步推导而来，只需要将上一步所走的路存起来,最后再把l到r这个区间所有的概率加起来即可。 代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;double dp[2][210];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int n,m,l,r; while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;l&gt;&gt;r&amp;&amp;n+m+l+r)&#123; int t=0; for(int i=0;i&lt;=n;i++) dp[0][i]=0; dp[0][0]=1; while(m--)&#123; int x; cin&gt;&gt;x; for(int i=0;i&lt;n;i++) dp[t^1][i]=0; for(int i=0;i&lt;n;i++)&#123; if(dp[t][i])&#123; dp[t^1][(i+x)%n]+=0.5*dp[t][i]; dp[t^1][(i-x+n)%n]+=0.5*dp[t][i]; &#125; &#125; t^=1; &#125; double ans=0; for(int i=l-1;i&lt;=r-1;i++)&#123; ans+=dp[t][i]; &#125; printf("%.4lf\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>概率dp</category>
      </categories>
      <tags>
        <tag>概率dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论问题之质数]]></title>
    <url>%2F2019%2F04%2F12%2F%E6%95%B0%E8%AE%BA_%E8%B4%A8%E6%95%B0_%E6%95%B0%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[质数定义若一个正整数无法被1和它自身之外的任何自然数整除，则称该数为质数（素数），否则该数为合数。 质数的判定用试除法：1234567bool is_prime(int n)&#123; if(n&lt;2) return false; for(int i=2;i&lt;=sqrt(n);i++)&#123; if(n%i==0) return false; &#125; return true;&#125; 质数的筛选方法：埃式筛法和线性筛法：链接（之前写过，就不写了）。 质因数分解算术基本定理： 任何一个不大于1的正整数都能唯一分解为有限个质数的乘积，可写作 N=p_1^c1*p_2^c2*p_3^c3*……p_m^cm​ 其中ci为正整数，pi为质数，满足p1]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>质数</tag>
      </tags>
  </entry>
</search>
